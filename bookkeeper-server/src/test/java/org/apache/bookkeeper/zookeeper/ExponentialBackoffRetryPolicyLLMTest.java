/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.zookeeper;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.any;
import static org.hamcrest.Matchers.anyOf;
import static org.hamcrest.Matchers.both;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.params.provider.ValueSource.strings;

import java.util.HashSet;
import java.util.Set;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

/**
 * Test class for ExponentialBackoffRetryPolicy - LLM Generated Tests.
 * 
 * This test suite focuses on comprehensive behavior testing using
 * parameterized tests, nested test contexts, and various test scenarios
 * generated by language learning model reasoning.
 */
@DisplayName("ExponentialBackoffRetryPolicy - LLM Generated Tests")
class ExponentialBackoffRetryPolicyLLMTest {

    private ExponentialBackoffRetryPolicy retryPolicy;

    @BeforeEach
    void setUp() {
        retryPolicy = new ExponentialBackoffRetryPolicy(100L, 5);
    }

    /**
     * Nested test class for allowRetry behavior testing
     */
    @Nested
    @DisplayName("allowRetry Behavior Tests")
    class AllowRetryTests {

        /**
         * Test: allowRetry with various retry counts
         * Uses parameterized testing to verify boundary behavior
         */
        @ParameterizedTest(name = "allowRetry({0}, 0) should return {1}")
        @CsvSource({
            "0, true",
            "1, true",
            "2, true",
            "3, true",
            "4, true",
            "5, true",
            "6, false",
            "7, false",
            "10, false",
            "100, false"
        })
        @DisplayName("allowRetry should correctly handle boundary conditions")
        void testAllowRetryBoundaryConditions(int retryCount, boolean expected) {
            boolean result = retryPolicy.allowRetry(retryCount, 0L);
            assertEquals(expected, result, 
                "allowRetry(" + retryCount + ") should return " + expected);
        }

        /**
         * Test: allowRetry is independent of elapsed time
         */
        @ParameterizedTest(name = "allowRetry at count {0} with elapsed {1}ms")
        @CsvSource({
            "0, 0",
            "0, 1000",
            "3, 5000",
            "5, 10000"
        })
        @DisplayName("allowRetry should be independent of elapsed retry time")
        void testAllowRetryElapsedTimeIndependence(int retryCount, long elapsedTime) {
            boolean resultWithoutTime = retryPolicy.allowRetry(retryCount, 0L);
            boolean resultWithTime = retryPolicy.allowRetry(retryCount, elapsedTime);
            assertEquals(resultWithoutTime, resultWithTime,
                "Result should be independent of elapsed time");
        }

        /**
         * Test: allowRetry transition at boundary
         */
        @Test
        @DisplayName("allowRetry should transition from true to false at maxRetries boundary")
        void testAllowRetryTransition() {
            assertTrue(retryPolicy.allowRetry(5, 0L), "Should allow at max retries");
            assertFalse(retryPolicy.allowRetry(6, 0L), "Should reject beyond max retries");
        }
    }

    /**
     * Nested test class for nextRetryWaitTime behavior
     */
    @Nested
    @DisplayName("nextRetryWaitTime Behavior Tests")
    class NextRetryWaitTimeTests {

        /**
         * Test: Backoff time increases with retry count
         */
        @Test
        @DisplayName("Backoff times should generally increase with retry count")
        void testBackoffTimeIncrease() {
            long[] backoffTimes = new long[6];
            for (int i = 0; i < 6; i++) {
                backoffTimes[i] = retryPolicy.nextRetryWaitTime(i, 0L);
            }

            // Verify increasing trend (allowing for randomization)
            for (int i = 0; i < backoffTimes.length - 1; i++) {
                assertThat(backoffTimes[i + 1], 
                    greaterThanOrEqualTo(backoffTimes[i]));
            }
        }

        /**
         * Test: Backoff time respects base backoff
         */
        @ParameterizedTest(name = "Backoff at retry {0}")
        @ValueSource(ints = {0, 1, 2, 3, 4, 5})
        @DisplayName("All backoff times should be >= base backoff time")
        void testBackoffMinimumBound(int retryCount) {
            long backoffTime = retryPolicy.nextRetryWaitTime(retryCount, 0L);
            assertThat(backoffTime, greaterThanOrEqualTo(100L));
        }

        /**
         * Test: Backoff variability due to randomization
         */
        @Test
        @DisplayName("nextRetryWaitTime should produce varied results due to randomization")
        void testBackoffRandomization() {
            int retryCount = 2;
            Set<Long> backoffValues = new HashSet<>();

            // Collect multiple backoff values
            for (int i = 0; i < 100; i++) {
                long backoff = retryPolicy.nextRetryWaitTime(retryCount, 0L);
                backoffValues.add(backoff);
            }

            // Should produce multiple different values due to randomization
            assertTrue(backoffValues.size() > 1, 
                "Backoff should vary due to randomization, got " + backoffValues.size() + " unique values");
        }

        /**
         * Test: Exponential growth pattern
         */
        @Test
        @DisplayName("Higher retry counts should have larger maximum possible backoff")
        void testExponentialGrowthPattern() {
            long maxBackoff0 = 100L * Math.max(1, 1 << 1);      // retryCount=0: 100 * 2 = 200
            long maxBackoff3 = 100L * Math.max(1, 1 << 4);      // retryCount=3: 100 * 16 = 1600
            long maxBackoff5 = 100L * Math.max(1, 1 << 6);      // retryCount=5: 100 * 64 = 6400

            assertEquals(200L, maxBackoff0, "Max backoff at count 0 should be 200");
            assertEquals(1600L, maxBackoff3, "Max backoff at count 3 should be 1600");
            assertEquals(6400L, maxBackoff5, "Max backoff at count 5 should be 6400");
        }
    }

    /**
     * Nested test class for combined scenarios
     */
    @Nested
    @DisplayName("Combined Behavior Tests")
    class CombinedBehaviorTests {

        /**
         * Test: Full retry sequence
         */
        @Test
        @DisplayName("Complete retry sequence from 0 to max retries")
        void testCompleteRetrySequence() {
            for (int i = 0; i <= 5; i++) {
                assertTrue(retryPolicy.allowRetry(i, 1000L * i),
                    "Should allow retry at count " + i);
                
                long backoff = retryPolicy.nextRetryWaitTime(i, 1000L * i);
                assertThat(backoff, greaterThanOrEqualTo(100L),
                    "Backoff at count " + i + " should be positive");
            }
            
            assertFalse(retryPolicy.allowRetry(6, 6000L),
                "Should reject retry beyond max");
        }

        /**
         * Test: Different policy configurations
         */
        @ParameterizedTest(name = "base={0}, maxRetries={1}")
        @CsvSource({
            "10, 3",
            "50, 5",
            "100, 10",
            "1000, 1"
        })
        @DisplayName("Different configurations should work correctly")
        void testDifferentConfigurations(long baseBackoff, int maxRetries) {
            ExponentialBackoffRetryPolicy policy = 
                new ExponentialBackoffRetryPolicy(baseBackoff, maxRetries);

            // Test at max retries
            assertTrue(policy.allowRetry(maxRetries, 0L),
                "Should allow at max retries");
            assertFalse(policy.allowRetry(maxRetries + 1, 0L),
                "Should reject beyond max");

            // Test backoff timing
            long backoff = policy.nextRetryWaitTime(0, 0L);
            assertThat(backoff, greaterThanOrEqualTo(baseBackoff),
                "Backoff should respect base configuration");
        }

        /**
         * Test: Elapsed time parameter variations
         */
        @ParameterizedTest(name = "elapsedTime={0}")
        @ValueSource(longs = {0L, 100L, 1000L, 10000L, 100000L})
        @DisplayName("nextRetryWaitTime should handle various elapsed times")
        void testElapsedTimeVariations(long elapsedTime) {
            for (int retryCount = 0; retryCount <= 5; retryCount++) {
                long backoff = retryPolicy.nextRetryWaitTime(retryCount, elapsedTime);
                assertThat(backoff, greaterThanOrEqualTo(100L),
                    "Backoff should be positive at retry " + retryCount);
            }
        }
    }

    /**
     * Nested test class for edge cases and special scenarios
     */
    @Nested
    @DisplayName("Edge Cases and Special Scenarios")
    class EdgeCasesTests {

        /**
         * Test: Zero base backoff handling
         */
        @Test
        @DisplayName("Policy with zero base backoff should still work")
        void testZeroBaseBackoff() {
            ExponentialBackoffRetryPolicy policy = 
                new ExponentialBackoffRetryPolicy(0L, 3);

            assertTrue(policy.allowRetry(0, 0L), "Should allow at count 0");
            assertFalse(policy.allowRetry(4, 0L), "Should reject at count 4");
            
            long backoff = policy.nextRetryWaitTime(0, 0L);
            assertThat(backoff, greaterThanOrEqualTo(0L), "Backoff should be non-negative");
        }

        /**
         * Test: Large retry counts
         */
        @Test
        @DisplayName("Policy should handle large max retry counts")
        void testLargeMaxRetries() {
            ExponentialBackoffRetryPolicy policy = 
                new ExponentialBackoffRetryPolicy(100L, 1000);

            assertTrue(policy.allowRetry(1000, 0L), "Should allow at max 1000");
            assertFalse(policy.allowRetry(1001, 0L), "Should reject at 1001");
        }

        /**
         * Test: Negative elapsed time (edge case)
         */
        @Test
        @DisplayName("Policy should handle negative elapsed time values")
        void testNegativeElapsedTime() {
            assertTrue(retryPolicy.allowRetry(2, -1000L),
                "Should allow even with negative elapsed time");
            
            long backoff = retryPolicy.nextRetryWaitTime(2, -5000L);
            assertThat(backoff, greaterThanOrEqualTo(100L),
                "Should produce valid backoff with negative elapsed time");
        }

        /**
         * Test: Maximum integer retry count
         */
        @Test
        @DisplayName("Policy should handle Integer.MAX_VALUE retry count")
        void testMaxIntRetryCount() {
            boolean result = retryPolicy.allowRetry(Integer.MAX_VALUE, 0L);
            assertFalse(result, "Should reject Integer.MAX_VALUE retry count");
        }
    }

    /**
     * Test persistence of policy configuration
     */
    @Test
    @DisplayName("Policy configuration should remain consistent across multiple calls")
    void testConfigurationPersistence() {
        // Make multiple calls
        for (int i = 0; i < 100; i++) {
            assertTrue(retryPolicy.allowRetry(5, i * 1000L),
                "Configuration should remain consistent");
            assertFalse(retryPolicy.allowRetry(6, i * 1000L),
                "Configuration should remain consistent");
        }
    }
}
