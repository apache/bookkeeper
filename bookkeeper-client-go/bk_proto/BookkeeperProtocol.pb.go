// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: BookkeeperProtocol.proto

package DataFormats

import (
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//*
// Protocol Versions.
type ProtocolVersion int32

const (
	ProtocolVersion_VERSION_ONE   ProtocolVersion = 1
	ProtocolVersion_VERSION_TWO   ProtocolVersion = 2
	ProtocolVersion_VERSION_THREE ProtocolVersion = 3
)

var ProtocolVersion_name = map[int32]string{
	1: "VERSION_ONE",
	2: "VERSION_TWO",
	3: "VERSION_THREE",
}

var ProtocolVersion_value = map[string]int32{
	"VERSION_ONE":   1,
	"VERSION_TWO":   2,
	"VERSION_THREE": 3,
}

func (x ProtocolVersion) Enum() *ProtocolVersion {
	p := new(ProtocolVersion)
	*p = x
	return p
}

func (x ProtocolVersion) String() string {
	return proto.EnumName(ProtocolVersion_name, int32(x))
}

func (x *ProtocolVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProtocolVersion_value, data, "ProtocolVersion")
	if err != nil {
		return err
	}
	*x = ProtocolVersion(value)
	return nil
}

func (ProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{0}
}

//*
// Status codes.
type StatusCode int32

const (
	StatusCode_EOK StatusCode = 0
	// Server side Errors 4xx
	StatusCode_ENOLEDGER StatusCode = 402
	StatusCode_ENOENTRY  StatusCode = 403
	StatusCode_EBADREQ   StatusCode = 404
	// IO/access errors 5xx
	StatusCode_EIO              StatusCode = 501
	StatusCode_EUA              StatusCode = 502
	StatusCode_EBADVERSION      StatusCode = 503
	StatusCode_EFENCED          StatusCode = 504
	StatusCode_EREADONLY        StatusCode = 505
	StatusCode_ETOOMANYREQUESTS StatusCode = 506
)

var StatusCode_name = map[int32]string{
	0:   "EOK",
	402: "ENOLEDGER",
	403: "ENOENTRY",
	404: "EBADREQ",
	501: "EIO",
	502: "EUA",
	503: "EBADVERSION",
	504: "EFENCED",
	505: "EREADONLY",
	506: "ETOOMANYREQUESTS",
}

var StatusCode_value = map[string]int32{
	"EOK":              0,
	"ENOLEDGER":        402,
	"ENOENTRY":         403,
	"EBADREQ":          404,
	"EIO":              501,
	"EUA":              502,
	"EBADVERSION":      503,
	"EFENCED":          504,
	"EREADONLY":        505,
	"ETOOMANYREQUESTS": 506,
}

func (x StatusCode) Enum() *StatusCode {
	p := new(StatusCode)
	*p = x
	return p
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (x *StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StatusCode_value, data, "StatusCode")
	if err != nil {
		return err
	}
	*x = StatusCode(value)
	return nil
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{1}
}

//*
// Supported operations by this protocol.
type OperationType int32

const (
	OperationType_READ_ENTRY OperationType = 1
	OperationType_ADD_ENTRY  OperationType = 2
	// Not supported yet.
	OperationType_RANGE_READ_ENTRY              OperationType = 3
	OperationType_RANGE_ADD_ENTRY               OperationType = 4
	OperationType_AUTH                          OperationType = 5
	OperationType_WRITE_LAC                     OperationType = 6
	OperationType_READ_LAC                      OperationType = 7
	OperationType_GET_BOOKIE_INFO               OperationType = 8
	OperationType_START_TLS                     OperationType = 9
	OperationType_FORCE_LEDGER                  OperationType = 10
	OperationType_GET_LIST_OF_ENTRIES_OF_LEDGER OperationType = 11
)

var OperationType_name = map[int32]string{
	1:  "READ_ENTRY",
	2:  "ADD_ENTRY",
	3:  "RANGE_READ_ENTRY",
	4:  "RANGE_ADD_ENTRY",
	5:  "AUTH",
	6:  "WRITE_LAC",
	7:  "READ_LAC",
	8:  "GET_BOOKIE_INFO",
	9:  "START_TLS",
	10: "FORCE_LEDGER",
	11: "GET_LIST_OF_ENTRIES_OF_LEDGER",
}

var OperationType_value = map[string]int32{
	"READ_ENTRY":                    1,
	"ADD_ENTRY":                     2,
	"RANGE_READ_ENTRY":              3,
	"RANGE_ADD_ENTRY":               4,
	"AUTH":                          5,
	"WRITE_LAC":                     6,
	"READ_LAC":                      7,
	"GET_BOOKIE_INFO":               8,
	"START_TLS":                     9,
	"FORCE_LEDGER":                  10,
	"GET_LIST_OF_ENTRIES_OF_LEDGER": 11,
}

func (x OperationType) Enum() *OperationType {
	p := new(OperationType)
	*p = x
	return p
}

func (x OperationType) String() string {
	return proto.EnumName(OperationType_name, int32(x))
}

func (x *OperationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OperationType_value, data, "OperationType")
	if err != nil {
		return err
	}
	*x = OperationType(value)
	return nil
}

func (OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{2}
}

type ReadRequest_Flag int32

const (
	ReadRequest_FENCE_LEDGER    ReadRequest_Flag = 1
	ReadRequest_ENTRY_PIGGYBACK ReadRequest_Flag = 2
)

var ReadRequest_Flag_name = map[int32]string{
	1: "FENCE_LEDGER",
	2: "ENTRY_PIGGYBACK",
}

var ReadRequest_Flag_value = map[string]int32{
	"FENCE_LEDGER":    1,
	"ENTRY_PIGGYBACK": 2,
}

func (x ReadRequest_Flag) Enum() *ReadRequest_Flag {
	p := new(ReadRequest_Flag)
	*p = x
	return p
}

func (x ReadRequest_Flag) String() string {
	return proto.EnumName(ReadRequest_Flag_name, int32(x))
}

func (x *ReadRequest_Flag) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReadRequest_Flag_value, data, "ReadRequest_Flag")
	if err != nil {
		return err
	}
	*x = ReadRequest_Flag(value)
	return nil
}

func (ReadRequest_Flag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{3, 0}
}

type AddRequest_Flag int32

const (
	AddRequest_RECOVERY_ADD AddRequest_Flag = 1
)

var AddRequest_Flag_name = map[int32]string{
	1: "RECOVERY_ADD",
}

var AddRequest_Flag_value = map[string]int32{
	"RECOVERY_ADD": 1,
}

func (x AddRequest_Flag) Enum() *AddRequest_Flag {
	p := new(AddRequest_Flag)
	*p = x
	return p
}

func (x AddRequest_Flag) String() string {
	return proto.EnumName(AddRequest_Flag_name, int32(x))
}

func (x *AddRequest_Flag) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AddRequest_Flag_value, data, "AddRequest_Flag")
	if err != nil {
		return err
	}
	*x = AddRequest_Flag(value)
	return nil
}

func (AddRequest_Flag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{4, 0}
}

type GetBookieInfoRequest_Flags int32

const (
	GetBookieInfoRequest_TOTAL_DISK_CAPACITY GetBookieInfoRequest_Flags = 1
	GetBookieInfoRequest_FREE_DISK_SPACE     GetBookieInfoRequest_Flags = 2
)

var GetBookieInfoRequest_Flags_name = map[int32]string{
	1: "TOTAL_DISK_CAPACITY",
	2: "FREE_DISK_SPACE",
}

var GetBookieInfoRequest_Flags_value = map[string]int32{
	"TOTAL_DISK_CAPACITY": 1,
	"FREE_DISK_SPACE":     2,
}

func (x GetBookieInfoRequest_Flags) Enum() *GetBookieInfoRequest_Flags {
	p := new(GetBookieInfoRequest_Flags)
	*p = x
	return p
}

func (x GetBookieInfoRequest_Flags) String() string {
	return proto.EnumName(GetBookieInfoRequest_Flags_name, int32(x))
}

func (x *GetBookieInfoRequest_Flags) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetBookieInfoRequest_Flags_value, data, "GetBookieInfoRequest_Flags")
	if err != nil {
		return err
	}
	*x = GetBookieInfoRequest_Flags(value)
	return nil
}

func (GetBookieInfoRequest_Flags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{9, 0}
}

//*
// Packet header for all requests.
type BKPacketHeader struct {
	Version              *ProtocolVersion `protobuf:"varint,1,req,name=version,enum=ProtocolVersion" json:"version,omitempty"`
	Operation            *OperationType   `protobuf:"varint,2,req,name=operation,enum=OperationType" json:"operation,omitempty"`
	TxnId                *uint64          `protobuf:"varint,3,req,name=txnId" json:"txnId,omitempty"`
	Priority             *uint32          `protobuf:"varint,4,opt,name=priority,def=0" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *BKPacketHeader) Reset()         { *m = BKPacketHeader{} }
func (m *BKPacketHeader) String() string { return proto.CompactTextString(m) }
func (*BKPacketHeader) ProtoMessage()    {}
func (*BKPacketHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{0}
}
func (m *BKPacketHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BKPacketHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BKPacketHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BKPacketHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BKPacketHeader.Merge(m, src)
}
func (m *BKPacketHeader) XXX_Size() int {
	return m.Size()
}
func (m *BKPacketHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BKPacketHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BKPacketHeader proto.InternalMessageInfo

const Default_BKPacketHeader_Priority uint32 = 0

func (m *BKPacketHeader) GetVersion() ProtocolVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ProtocolVersion_VERSION_ONE
}

func (m *BKPacketHeader) GetOperation() OperationType {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return OperationType_READ_ENTRY
}

func (m *BKPacketHeader) GetTxnId() uint64 {
	if m != nil && m.TxnId != nil {
		return *m.TxnId
	}
	return 0
}

func (m *BKPacketHeader) GetPriority() uint32 {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return Default_BKPacketHeader_Priority
}

type ContextPair struct {
	Key                  *string  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContextPair) Reset()         { *m = ContextPair{} }
func (m *ContextPair) String() string { return proto.CompactTextString(m) }
func (*ContextPair) ProtoMessage()    {}
func (*ContextPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{1}
}
func (m *ContextPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextPair.Merge(m, src)
}
func (m *ContextPair) XXX_Size() int {
	return m.Size()
}
func (m *ContextPair) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextPair.DiscardUnknown(m)
}

var xxx_messageInfo_ContextPair proto.InternalMessageInfo

func (m *ContextPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ContextPair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Request struct {
	Header *BKPacketHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	// Requests
	ReadRequest                     *ReadRequest                     `protobuf:"bytes,100,opt,name=readRequest" json:"readRequest,omitempty"`
	AddRequest                      *AddRequest                      `protobuf:"bytes,101,opt,name=addRequest" json:"addRequest,omitempty"`
	AuthRequest                     *AuthMessage                     `protobuf:"bytes,102,opt,name=authRequest" json:"authRequest,omitempty"`
	WriteLacRequest                 *WriteLacRequest                 `protobuf:"bytes,103,opt,name=writeLacRequest" json:"writeLacRequest,omitempty"`
	ReadLacRequest                  *ReadLacRequest                  `protobuf:"bytes,104,opt,name=readLacRequest" json:"readLacRequest,omitempty"`
	GetBookieInfoRequest            *GetBookieInfoRequest            `protobuf:"bytes,105,opt,name=getBookieInfoRequest" json:"getBookieInfoRequest,omitempty"`
	StartTLSRequest                 *StartTLSRequest                 `protobuf:"bytes,106,opt,name=startTLSRequest" json:"startTLSRequest,omitempty"`
	ForceLedgerRequest              *ForceLedgerRequest              `protobuf:"bytes,107,opt,name=forceLedgerRequest" json:"forceLedgerRequest,omitempty"`
	GetListOfEntriesOfLedgerRequest *GetListOfEntriesOfLedgerRequest `protobuf:"bytes,108,opt,name=getListOfEntriesOfLedgerRequest" json:"getListOfEntriesOfLedgerRequest,omitempty"`
	// to pass MDC context
	RequestContext       []*ContextPair `protobuf:"bytes,200,rep,name=requestContext" json:"requestContext,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{2}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetHeader() *BKPacketHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Request) GetReadRequest() *ReadRequest {
	if m != nil {
		return m.ReadRequest
	}
	return nil
}

func (m *Request) GetAddRequest() *AddRequest {
	if m != nil {
		return m.AddRequest
	}
	return nil
}

func (m *Request) GetAuthRequest() *AuthMessage {
	if m != nil {
		return m.AuthRequest
	}
	return nil
}

func (m *Request) GetWriteLacRequest() *WriteLacRequest {
	if m != nil {
		return m.WriteLacRequest
	}
	return nil
}

func (m *Request) GetReadLacRequest() *ReadLacRequest {
	if m != nil {
		return m.ReadLacRequest
	}
	return nil
}

func (m *Request) GetGetBookieInfoRequest() *GetBookieInfoRequest {
	if m != nil {
		return m.GetBookieInfoRequest
	}
	return nil
}

func (m *Request) GetStartTLSRequest() *StartTLSRequest {
	if m != nil {
		return m.StartTLSRequest
	}
	return nil
}

func (m *Request) GetForceLedgerRequest() *ForceLedgerRequest {
	if m != nil {
		return m.ForceLedgerRequest
	}
	return nil
}

func (m *Request) GetGetListOfEntriesOfLedgerRequest() *GetListOfEntriesOfLedgerRequest {
	if m != nil {
		return m.GetListOfEntriesOfLedgerRequest
	}
	return nil
}

func (m *Request) GetRequestContext() []*ContextPair {
	if m != nil {
		return m.RequestContext
	}
	return nil
}

type ReadRequest struct {
	Flag     *ReadRequest_Flag `protobuf:"varint,100,opt,name=flag,enum=ReadRequest_Flag" json:"flag,omitempty"`
	LedgerId *int64            `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	// entryId will be -1 for reading the LAST_ADD_CONFIRMED entry.
	EntryId *int64 `protobuf:"varint,2,req,name=entryId" json:"entryId,omitempty"`
	// Used while fencing a ledger.
	MasterKey []byte `protobuf:"bytes,3,opt,name=masterKey" json:"masterKey,omitempty"`
	// Used for waiting on last add confirmed update
	PreviousLAC *int64 `protobuf:"varint,4,opt,name=previousLAC" json:"previousLAC,omitempty"`
	// Used as a timeout (in milliseconds) for the long polling request
	TimeOut              *int64   `protobuf:"varint,5,opt,name=timeOut" json:"timeOut,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{3}
}
func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(m, src)
}
func (m *ReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

func (m *ReadRequest) GetFlag() ReadRequest_Flag {
	if m != nil && m.Flag != nil {
		return *m.Flag
	}
	return ReadRequest_FENCE_LEDGER
}

func (m *ReadRequest) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *ReadRequest) GetEntryId() int64 {
	if m != nil && m.EntryId != nil {
		return *m.EntryId
	}
	return 0
}

func (m *ReadRequest) GetMasterKey() []byte {
	if m != nil {
		return m.MasterKey
	}
	return nil
}

func (m *ReadRequest) GetPreviousLAC() int64 {
	if m != nil && m.PreviousLAC != nil {
		return *m.PreviousLAC
	}
	return 0
}

func (m *ReadRequest) GetTimeOut() int64 {
	if m != nil && m.TimeOut != nil {
		return *m.TimeOut
	}
	return 0
}

type AddRequest struct {
	Flag                 *AddRequest_Flag `protobuf:"varint,100,opt,name=flag,enum=AddRequest_Flag" json:"flag,omitempty"`
	LedgerId             *int64           `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	EntryId              *int64           `protobuf:"varint,2,req,name=entryId" json:"entryId,omitempty"`
	MasterKey            []byte           `protobuf:"bytes,3,req,name=masterKey" json:"masterKey,omitempty"`
	Body                 []byte           `protobuf:"bytes,4,req,name=body" json:"body,omitempty"`
	WriteFlags           *int32           `protobuf:"varint,5,opt,name=writeFlags" json:"writeFlags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AddRequest) Reset()         { *m = AddRequest{} }
func (m *AddRequest) String() string { return proto.CompactTextString(m) }
func (*AddRequest) ProtoMessage()    {}
func (*AddRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{4}
}
func (m *AddRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddRequest.Merge(m, src)
}
func (m *AddRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddRequest proto.InternalMessageInfo

func (m *AddRequest) GetFlag() AddRequest_Flag {
	if m != nil && m.Flag != nil {
		return *m.Flag
	}
	return AddRequest_RECOVERY_ADD
}

func (m *AddRequest) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *AddRequest) GetEntryId() int64 {
	if m != nil && m.EntryId != nil {
		return *m.EntryId
	}
	return 0
}

func (m *AddRequest) GetMasterKey() []byte {
	if m != nil {
		return m.MasterKey
	}
	return nil
}

func (m *AddRequest) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *AddRequest) GetWriteFlags() int32 {
	if m != nil && m.WriteFlags != nil {
		return *m.WriteFlags
	}
	return 0
}

type StartTLSRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartTLSRequest) Reset()         { *m = StartTLSRequest{} }
func (m *StartTLSRequest) String() string { return proto.CompactTextString(m) }
func (*StartTLSRequest) ProtoMessage()    {}
func (*StartTLSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{5}
}
func (m *StartTLSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTLSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTLSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartTLSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTLSRequest.Merge(m, src)
}
func (m *StartTLSRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartTLSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTLSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartTLSRequest proto.InternalMessageInfo

type WriteLacRequest struct {
	LedgerId             *int64   `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	Lac                  *int64   `protobuf:"varint,2,req,name=lac" json:"lac,omitempty"`
	MasterKey            []byte   `protobuf:"bytes,3,req,name=masterKey" json:"masterKey,omitempty"`
	Body                 []byte   `protobuf:"bytes,4,req,name=body" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteLacRequest) Reset()         { *m = WriteLacRequest{} }
func (m *WriteLacRequest) String() string { return proto.CompactTextString(m) }
func (*WriteLacRequest) ProtoMessage()    {}
func (*WriteLacRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{6}
}
func (m *WriteLacRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteLacRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteLacRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteLacRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteLacRequest.Merge(m, src)
}
func (m *WriteLacRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteLacRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteLacRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteLacRequest proto.InternalMessageInfo

func (m *WriteLacRequest) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *WriteLacRequest) GetLac() int64 {
	if m != nil && m.Lac != nil {
		return *m.Lac
	}
	return 0
}

func (m *WriteLacRequest) GetMasterKey() []byte {
	if m != nil {
		return m.MasterKey
	}
	return nil
}

func (m *WriteLacRequest) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type ForceLedgerRequest struct {
	LedgerId             *int64   `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForceLedgerRequest) Reset()         { *m = ForceLedgerRequest{} }
func (m *ForceLedgerRequest) String() string { return proto.CompactTextString(m) }
func (*ForceLedgerRequest) ProtoMessage()    {}
func (*ForceLedgerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{7}
}
func (m *ForceLedgerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForceLedgerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForceLedgerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForceLedgerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForceLedgerRequest.Merge(m, src)
}
func (m *ForceLedgerRequest) XXX_Size() int {
	return m.Size()
}
func (m *ForceLedgerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ForceLedgerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ForceLedgerRequest proto.InternalMessageInfo

func (m *ForceLedgerRequest) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

type ReadLacRequest struct {
	LedgerId             *int64   `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadLacRequest) Reset()         { *m = ReadLacRequest{} }
func (m *ReadLacRequest) String() string { return proto.CompactTextString(m) }
func (*ReadLacRequest) ProtoMessage()    {}
func (*ReadLacRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{8}
}
func (m *ReadLacRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadLacRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadLacRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadLacRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadLacRequest.Merge(m, src)
}
func (m *ReadLacRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadLacRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadLacRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadLacRequest proto.InternalMessageInfo

func (m *ReadLacRequest) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

type GetBookieInfoRequest struct {
	// bitwise OR of Flags
	Requested            *int64   `protobuf:"varint,1,opt,name=requested" json:"requested,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBookieInfoRequest) Reset()         { *m = GetBookieInfoRequest{} }
func (m *GetBookieInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetBookieInfoRequest) ProtoMessage()    {}
func (*GetBookieInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{9}
}
func (m *GetBookieInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBookieInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBookieInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBookieInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBookieInfoRequest.Merge(m, src)
}
func (m *GetBookieInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBookieInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBookieInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBookieInfoRequest proto.InternalMessageInfo

func (m *GetBookieInfoRequest) GetRequested() int64 {
	if m != nil && m.Requested != nil {
		return *m.Requested
	}
	return 0
}

type GetListOfEntriesOfLedgerRequest struct {
	LedgerId             *int64   `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetListOfEntriesOfLedgerRequest) Reset()         { *m = GetListOfEntriesOfLedgerRequest{} }
func (m *GetListOfEntriesOfLedgerRequest) String() string { return proto.CompactTextString(m) }
func (*GetListOfEntriesOfLedgerRequest) ProtoMessage()    {}
func (*GetListOfEntriesOfLedgerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{10}
}
func (m *GetListOfEntriesOfLedgerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetListOfEntriesOfLedgerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetListOfEntriesOfLedgerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetListOfEntriesOfLedgerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetListOfEntriesOfLedgerRequest.Merge(m, src)
}
func (m *GetListOfEntriesOfLedgerRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetListOfEntriesOfLedgerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetListOfEntriesOfLedgerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetListOfEntriesOfLedgerRequest proto.InternalMessageInfo

func (m *GetListOfEntriesOfLedgerRequest) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

type Response struct {
	Header *BKPacketHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	// EOK if the underlying request succeeded. Each individual response
	// has a more meaningful status. EBADREQ if we have an unsupported request.
	Status *StatusCode `protobuf:"varint,2,req,name=status,enum=StatusCode" json:"status,omitempty"`
	// Response
	ReadResponse                     *ReadResponse                     `protobuf:"bytes,100,opt,name=readResponse" json:"readResponse,omitempty"`
	AddResponse                      *AddResponse                      `protobuf:"bytes,101,opt,name=addResponse" json:"addResponse,omitempty"`
	AuthResponse                     *AuthMessage                      `protobuf:"bytes,102,opt,name=authResponse" json:"authResponse,omitempty"`
	WriteLacResponse                 *WriteLacResponse                 `protobuf:"bytes,103,opt,name=writeLacResponse" json:"writeLacResponse,omitempty"`
	ReadLacResponse                  *ReadLacResponse                  `protobuf:"bytes,104,opt,name=readLacResponse" json:"readLacResponse,omitempty"`
	GetBookieInfoResponse            *GetBookieInfoResponse            `protobuf:"bytes,105,opt,name=getBookieInfoResponse" json:"getBookieInfoResponse,omitempty"`
	StartTLSResponse                 *StartTLSResponse                 `protobuf:"bytes,106,opt,name=startTLSResponse" json:"startTLSResponse,omitempty"`
	ForceLedgerResponse              *ForceLedgerResponse              `protobuf:"bytes,107,opt,name=forceLedgerResponse" json:"forceLedgerResponse,omitempty"`
	GetListOfEntriesOfLedgerResponse *GetListOfEntriesOfLedgerResponse `protobuf:"bytes,108,opt,name=getListOfEntriesOfLedgerResponse" json:"getListOfEntriesOfLedgerResponse,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}                          `json:"-"`
	XXX_unrecognized                 []byte                            `json:"-"`
	XXX_sizecache                    int32                             `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{11}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetHeader() *BKPacketHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Response) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *Response) GetReadResponse() *ReadResponse {
	if m != nil {
		return m.ReadResponse
	}
	return nil
}

func (m *Response) GetAddResponse() *AddResponse {
	if m != nil {
		return m.AddResponse
	}
	return nil
}

func (m *Response) GetAuthResponse() *AuthMessage {
	if m != nil {
		return m.AuthResponse
	}
	return nil
}

func (m *Response) GetWriteLacResponse() *WriteLacResponse {
	if m != nil {
		return m.WriteLacResponse
	}
	return nil
}

func (m *Response) GetReadLacResponse() *ReadLacResponse {
	if m != nil {
		return m.ReadLacResponse
	}
	return nil
}

func (m *Response) GetGetBookieInfoResponse() *GetBookieInfoResponse {
	if m != nil {
		return m.GetBookieInfoResponse
	}
	return nil
}

func (m *Response) GetStartTLSResponse() *StartTLSResponse {
	if m != nil {
		return m.StartTLSResponse
	}
	return nil
}

func (m *Response) GetForceLedgerResponse() *ForceLedgerResponse {
	if m != nil {
		return m.ForceLedgerResponse
	}
	return nil
}

func (m *Response) GetGetListOfEntriesOfLedgerResponse() *GetListOfEntriesOfLedgerResponse {
	if m != nil {
		return m.GetListOfEntriesOfLedgerResponse
	}
	return nil
}

type ReadResponse struct {
	Status   *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	LedgerId *int64      `protobuf:"varint,2,req,name=ledgerId" json:"ledgerId,omitempty"`
	EntryId  *int64      `protobuf:"varint,3,req,name=entryId" json:"entryId,omitempty"`
	Body     []byte      `protobuf:"bytes,4,opt,name=body" json:"body,omitempty"`
	// Piggyback LAC
	MaxLAC               *int64   `protobuf:"varint,5,opt,name=maxLAC" json:"maxLAC,omitempty"`
	LacUpdateTimestamp   *int64   `protobuf:"varint,6,opt,name=lacUpdateTimestamp" json:"lacUpdateTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadResponse) Reset()         { *m = ReadResponse{} }
func (m *ReadResponse) String() string { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()    {}
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{12}
}
func (m *ReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResponse.Merge(m, src)
}
func (m *ReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResponse proto.InternalMessageInfo

func (m *ReadResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *ReadResponse) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *ReadResponse) GetEntryId() int64 {
	if m != nil && m.EntryId != nil {
		return *m.EntryId
	}
	return 0
}

func (m *ReadResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ReadResponse) GetMaxLAC() int64 {
	if m != nil && m.MaxLAC != nil {
		return *m.MaxLAC
	}
	return 0
}

func (m *ReadResponse) GetLacUpdateTimestamp() int64 {
	if m != nil && m.LacUpdateTimestamp != nil {
		return *m.LacUpdateTimestamp
	}
	return 0
}

type AddResponse struct {
	Status               *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	LedgerId             *int64      `protobuf:"varint,2,req,name=ledgerId" json:"ledgerId,omitempty"`
	EntryId              *int64      `protobuf:"varint,3,req,name=entryId" json:"entryId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AddResponse) Reset()         { *m = AddResponse{} }
func (m *AddResponse) String() string { return proto.CompactTextString(m) }
func (*AddResponse) ProtoMessage()    {}
func (*AddResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{13}
}
func (m *AddResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddResponse.Merge(m, src)
}
func (m *AddResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddResponse proto.InternalMessageInfo

func (m *AddResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *AddResponse) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *AddResponse) GetEntryId() int64 {
	if m != nil && m.EntryId != nil {
		return *m.EntryId
	}
	return 0
}

type AuthMessage struct {
	AuthPluginName       *string  `protobuf:"bytes,1,req,name=authPluginName" json:"authPluginName,omitempty"`
	Payload              []byte   `protobuf:"bytes,2,req,name=payload" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthMessage) Reset()         { *m = AuthMessage{} }
func (m *AuthMessage) String() string { return proto.CompactTextString(m) }
func (*AuthMessage) ProtoMessage()    {}
func (*AuthMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{14}
}
func (m *AuthMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthMessage.Merge(m, src)
}
func (m *AuthMessage) XXX_Size() int {
	return m.Size()
}
func (m *AuthMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthMessage.DiscardUnknown(m)
}

var xxx_messageInfo_AuthMessage proto.InternalMessageInfo

func (m *AuthMessage) GetAuthPluginName() string {
	if m != nil && m.AuthPluginName != nil {
		return *m.AuthPluginName
	}
	return ""
}

func (m *AuthMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type WriteLacResponse struct {
	Status               *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	LedgerId             *int64      `protobuf:"varint,2,req,name=ledgerId" json:"ledgerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WriteLacResponse) Reset()         { *m = WriteLacResponse{} }
func (m *WriteLacResponse) String() string { return proto.CompactTextString(m) }
func (*WriteLacResponse) ProtoMessage()    {}
func (*WriteLacResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{15}
}
func (m *WriteLacResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteLacResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteLacResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteLacResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteLacResponse.Merge(m, src)
}
func (m *WriteLacResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteLacResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteLacResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteLacResponse proto.InternalMessageInfo

func (m *WriteLacResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *WriteLacResponse) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

type ForceLedgerResponse struct {
	Status               *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	LedgerId             *int64      `protobuf:"varint,2,req,name=ledgerId" json:"ledgerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ForceLedgerResponse) Reset()         { *m = ForceLedgerResponse{} }
func (m *ForceLedgerResponse) String() string { return proto.CompactTextString(m) }
func (*ForceLedgerResponse) ProtoMessage()    {}
func (*ForceLedgerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{16}
}
func (m *ForceLedgerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForceLedgerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForceLedgerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForceLedgerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForceLedgerResponse.Merge(m, src)
}
func (m *ForceLedgerResponse) XXX_Size() int {
	return m.Size()
}
func (m *ForceLedgerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ForceLedgerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ForceLedgerResponse proto.InternalMessageInfo

func (m *ForceLedgerResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *ForceLedgerResponse) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

type ReadLacResponse struct {
	Status               *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	LedgerId             *int64      `protobuf:"varint,2,req,name=ledgerId" json:"ledgerId,omitempty"`
	LacBody              []byte      `protobuf:"bytes,3,opt,name=lacBody" json:"lacBody,omitempty"`
	LastEntryBody        []byte      `protobuf:"bytes,4,opt,name=lastEntryBody" json:"lastEntryBody,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ReadLacResponse) Reset()         { *m = ReadLacResponse{} }
func (m *ReadLacResponse) String() string { return proto.CompactTextString(m) }
func (*ReadLacResponse) ProtoMessage()    {}
func (*ReadLacResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{17}
}
func (m *ReadLacResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadLacResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadLacResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadLacResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadLacResponse.Merge(m, src)
}
func (m *ReadLacResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadLacResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadLacResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadLacResponse proto.InternalMessageInfo

func (m *ReadLacResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *ReadLacResponse) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *ReadLacResponse) GetLacBody() []byte {
	if m != nil {
		return m.LacBody
	}
	return nil
}

func (m *ReadLacResponse) GetLastEntryBody() []byte {
	if m != nil {
		return m.LastEntryBody
	}
	return nil
}

type GetBookieInfoResponse struct {
	Status               *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	TotalDiskCapacity    *int64      `protobuf:"varint,2,opt,name=totalDiskCapacity" json:"totalDiskCapacity,omitempty"`
	FreeDiskSpace        *int64      `protobuf:"varint,3,opt,name=freeDiskSpace" json:"freeDiskSpace,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetBookieInfoResponse) Reset()         { *m = GetBookieInfoResponse{} }
func (m *GetBookieInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetBookieInfoResponse) ProtoMessage()    {}
func (*GetBookieInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{18}
}
func (m *GetBookieInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBookieInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBookieInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBookieInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBookieInfoResponse.Merge(m, src)
}
func (m *GetBookieInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBookieInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBookieInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBookieInfoResponse proto.InternalMessageInfo

func (m *GetBookieInfoResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *GetBookieInfoResponse) GetTotalDiskCapacity() int64 {
	if m != nil && m.TotalDiskCapacity != nil {
		return *m.TotalDiskCapacity
	}
	return 0
}

func (m *GetBookieInfoResponse) GetFreeDiskSpace() int64 {
	if m != nil && m.FreeDiskSpace != nil {
		return *m.FreeDiskSpace
	}
	return 0
}

type GetListOfEntriesOfLedgerResponse struct {
	Status                        *StatusCode `protobuf:"varint,1,req,name=status,enum=StatusCode" json:"status,omitempty"`
	LedgerId                      *int64      `protobuf:"varint,2,req,name=ledgerId" json:"ledgerId,omitempty"`
	AvailabilityOfEntriesOfLedger []byte      `protobuf:"bytes,3,opt,name=availabilityOfEntriesOfLedger" json:"availabilityOfEntriesOfLedger,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}    `json:"-"`
	XXX_unrecognized              []byte      `json:"-"`
	XXX_sizecache                 int32       `json:"-"`
}

func (m *GetListOfEntriesOfLedgerResponse) Reset()         { *m = GetListOfEntriesOfLedgerResponse{} }
func (m *GetListOfEntriesOfLedgerResponse) String() string { return proto.CompactTextString(m) }
func (*GetListOfEntriesOfLedgerResponse) ProtoMessage()    {}
func (*GetListOfEntriesOfLedgerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{19}
}
func (m *GetListOfEntriesOfLedgerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetListOfEntriesOfLedgerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetListOfEntriesOfLedgerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetListOfEntriesOfLedgerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetListOfEntriesOfLedgerResponse.Merge(m, src)
}
func (m *GetListOfEntriesOfLedgerResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetListOfEntriesOfLedgerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetListOfEntriesOfLedgerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetListOfEntriesOfLedgerResponse proto.InternalMessageInfo

func (m *GetListOfEntriesOfLedgerResponse) GetStatus() StatusCode {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return StatusCode_EOK
}

func (m *GetListOfEntriesOfLedgerResponse) GetLedgerId() int64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *GetListOfEntriesOfLedgerResponse) GetAvailabilityOfEntriesOfLedger() []byte {
	if m != nil {
		return m.AvailabilityOfEntriesOfLedger
	}
	return nil
}

type StartTLSResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartTLSResponse) Reset()         { *m = StartTLSResponse{} }
func (m *StartTLSResponse) String() string { return proto.CompactTextString(m) }
func (*StartTLSResponse) ProtoMessage()    {}
func (*StartTLSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_054377d42d427cd0, []int{20}
}
func (m *StartTLSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTLSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTLSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartTLSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTLSResponse.Merge(m, src)
}
func (m *StartTLSResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartTLSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTLSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartTLSResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("ProtocolVersion", ProtocolVersion_name, ProtocolVersion_value)
	proto.RegisterEnum("StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("OperationType", OperationType_name, OperationType_value)
	proto.RegisterEnum("ReadRequest_Flag", ReadRequest_Flag_name, ReadRequest_Flag_value)
	proto.RegisterEnum("AddRequest_Flag", AddRequest_Flag_name, AddRequest_Flag_value)
	proto.RegisterEnum("GetBookieInfoRequest_Flags", GetBookieInfoRequest_Flags_name, GetBookieInfoRequest_Flags_value)
	proto.RegisterType((*BKPacketHeader)(nil), "BKPacketHeader")
	proto.RegisterType((*ContextPair)(nil), "ContextPair")
	proto.RegisterType((*Request)(nil), "Request")
	proto.RegisterType((*ReadRequest)(nil), "ReadRequest")
	proto.RegisterType((*AddRequest)(nil), "AddRequest")
	proto.RegisterType((*StartTLSRequest)(nil), "StartTLSRequest")
	proto.RegisterType((*WriteLacRequest)(nil), "WriteLacRequest")
	proto.RegisterType((*ForceLedgerRequest)(nil), "ForceLedgerRequest")
	proto.RegisterType((*ReadLacRequest)(nil), "ReadLacRequest")
	proto.RegisterType((*GetBookieInfoRequest)(nil), "GetBookieInfoRequest")
	proto.RegisterType((*GetListOfEntriesOfLedgerRequest)(nil), "GetListOfEntriesOfLedgerRequest")
	proto.RegisterType((*Response)(nil), "Response")
	proto.RegisterType((*ReadResponse)(nil), "ReadResponse")
	proto.RegisterType((*AddResponse)(nil), "AddResponse")
	proto.RegisterType((*AuthMessage)(nil), "AuthMessage")
	proto.RegisterType((*WriteLacResponse)(nil), "WriteLacResponse")
	proto.RegisterType((*ForceLedgerResponse)(nil), "ForceLedgerResponse")
	proto.RegisterType((*ReadLacResponse)(nil), "ReadLacResponse")
	proto.RegisterType((*GetBookieInfoResponse)(nil), "GetBookieInfoResponse")
	proto.RegisterType((*GetListOfEntriesOfLedgerResponse)(nil), "GetListOfEntriesOfLedgerResponse")
	proto.RegisterType((*StartTLSResponse)(nil), "StartTLSResponse")
}

func init() { proto.RegisterFile("BookkeeperProtocol.proto", fileDescriptor_054377d42d427cd0) }

var fileDescriptor_054377d42d427cd0 = []byte{
	// 1484 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x6f, 0x1a, 0x47,
	0x1b, 0x7f, 0x97, 0xf5, 0x1f, 0xfc, 0x80, 0x61, 0x3c, 0xb6, 0xf3, 0xa2, 0xf7, 0x6d, 0x1c, 0xb2,
	0x4d, 0x5b, 0xcb, 0x49, 0x51, 0x6a, 0x29, 0xaa, 0x14, 0x29, 0x87, 0x05, 0x16, 0x1b, 0x99, 0xb0,
	0xce, 0xb0, 0x76, 0xe4, 0x13, 0x9a, 0xc0, 0x18, 0x6f, 0x8c, 0x59, 0xb2, 0x3b, 0xb8, 0xe1, 0x5b,
	0x54, 0x69, 0xaf, 0x55, 0x0f, 0x3d, 0x55, 0xea, 0xd7, 0xa8, 0x94, 0x63, 0x0f, 0xbd, 0xf4, 0x56,
	0xe5, 0x2b, 0x54, 0xfd, 0x7b, 0xaa, 0x66, 0x76, 0x80, 0x5d, 0x4c, 0xec, 0x54, 0x49, 0x6f, 0x33,
	0xbf, 0xf9, 0xfd, 0x9e, 0x79, 0x1e, 0x78, 0xfe, 0xcc, 0x42, 0xae, 0xe8, 0x79, 0xa7, 0xa7, 0x8c,
	0xf5, 0x99, 0xbf, 0xef, 0x7b, 0xdc, 0x6b, 0x79, 0xdd, 0x42, 0x5f, 0x2c, 0x8c, 0xaf, 0x35, 0xc8,
	0x14, 0xf7, 0xf6, 0x69, 0xeb, 0x94, 0xf1, 0x5d, 0x46, 0xdb, 0xcc, 0xc7, 0x5b, 0xb0, 0x78, 0xce,
	0xfc, 0xc0, 0xf5, 0x7a, 0x39, 0x2d, 0x9f, 0xd8, 0xcc, 0x6c, 0xa3, 0xc2, 0x48, 0x74, 0x18, 0xe2,
	0x64, 0x44, 0xc0, 0x77, 0x60, 0xc9, 0xeb, 0x33, 0x9f, 0x72, 0xc1, 0x4e, 0x48, 0x76, 0xa6, 0x60,
	0x8f, 0x10, 0x67, 0xd8, 0x67, 0x64, 0x42, 0xc0, 0x6b, 0x30, 0xcf, 0x9f, 0xf7, 0xaa, 0xed, 0x9c,
	0x9e, 0x4f, 0x6c, 0xce, 0x91, 0x70, 0x83, 0xaf, 0x43, 0xb2, 0xef, 0xbb, 0x9e, 0xef, 0xf2, 0x61,
	0x6e, 0x2e, 0xaf, 0x6d, 0x2e, 0xdf, 0xd7, 0xee, 0x92, 0x31, 0x64, 0xdc, 0x83, 0x54, 0xc9, 0xeb,
	0x71, 0xf6, 0x9c, 0xef, 0x53, 0xd7, 0xc7, 0x08, 0xf4, 0x53, 0x36, 0x94, 0x9e, 0x2d, 0x11, 0xb1,
	0x14, 0x56, 0xcf, 0x69, 0x77, 0xc0, 0xe4, 0xfd, 0x4b, 0x24, 0xdc, 0x18, 0xdf, 0xcc, 0xc3, 0x22,
	0x61, 0xcf, 0x06, 0x2c, 0xe0, 0xf8, 0x23, 0x58, 0x38, 0x91, 0xb1, 0x49, 0x59, 0x6a, 0x3b, 0x5b,
	0x88, 0x87, 0x4c, 0xd4, 0x31, 0x2e, 0x40, 0xca, 0x67, 0xb4, 0xad, 0x74, 0xb9, 0x76, 0x5e, 0xdb,
	0x4c, 0x6d, 0xa7, 0x0b, 0x64, 0x82, 0x91, 0x28, 0x01, 0xdf, 0x06, 0xa0, 0xed, 0x31, 0x9d, 0x49,
	0x7a, 0xaa, 0x60, 0x8e, 0x21, 0x12, 0x39, 0x16, 0xc6, 0xe9, 0x80, 0x9f, 0x8c, 0xd8, 0xc7, 0xca,
	0xb8, 0x39, 0xe0, 0x27, 0x0f, 0x59, 0x10, 0xd0, 0x0e, 0x23, 0x51, 0x02, 0xbe, 0x0f, 0xd9, 0xcf,
	0x7c, 0x97, 0xb3, 0x1a, 0x6d, 0x8d, 0x34, 0x1d, 0xa9, 0x41, 0x85, 0xc7, 0x71, 0x9c, 0x4c, 0x13,
	0xf1, 0xa7, 0x90, 0x11, 0x7e, 0x46, 0xa4, 0x27, 0x52, 0x9a, 0x95, 0xb1, 0x44, 0x94, 0x53, 0x34,
	0x5c, 0x85, 0xb5, 0x0e, 0xe3, 0x22, 0x5d, 0x5c, 0x56, 0xed, 0x1d, 0x7b, 0x23, 0xb9, 0x2b, 0xe5,
	0xeb, 0x85, 0x9d, 0x19, 0x87, 0x64, 0xa6, 0x44, 0xf8, 0x1f, 0x70, 0xea, 0x73, 0xa7, 0xd6, 0x18,
	0x59, 0x79, 0xaa, 0xfc, 0x6f, 0xc4, 0x71, 0x32, 0x4d, 0xc4, 0x25, 0xc0, 0xc7, 0x9e, 0xdf, 0x62,
	0x35, 0xd6, 0xee, 0x30, 0x7f, 0x24, 0x3f, 0x95, 0xf2, 0xd5, 0x42, 0xe5, 0xc2, 0x11, 0x99, 0x41,
	0xc7, 0x4f, 0xe1, 0x46, 0x87, 0xf1, 0x9a, 0x1b, 0x70, 0xfb, 0xd8, 0xea, 0x71, 0xdf, 0x65, 0x81,
	0x7d, 0x1c, 0xb7, 0xd8, 0x95, 0x16, 0xf3, 0x22, 0xac, 0xcb, 0x78, 0xe4, 0x2a, 0x43, 0xf8, 0x9e,
	0xf8, 0xc1, 0xe5, 0x52, 0x25, 0x6b, 0xee, 0xa5, 0x96, 0xd7, 0xe5, 0x1f, 0x1c, 0xc9, 0x5e, 0x32,
	0x45, 0x32, 0x7e, 0xd1, 0x20, 0x15, 0xc9, 0x2e, 0xfc, 0x01, 0xcc, 0x1d, 0x77, 0x69, 0x47, 0x66,
	0x5e, 0x66, 0x7b, 0x25, 0x9a, 0x79, 0x85, 0x4a, 0x97, 0x76, 0x88, 0x3c, 0xc6, 0xff, 0x83, 0x64,
	0x57, 0x5e, 0x5f, 0x6d, 0xcb, 0x94, 0xd6, 0xc9, 0x78, 0x8f, 0x73, 0xb0, 0xc8, 0x7a, 0xdc, 0x1f,
	0x56, 0xdb, 0xb2, 0x20, 0x74, 0x32, 0xda, 0xe2, 0xf7, 0x60, 0xe9, 0x8c, 0x06, 0x9c, 0xf9, 0x7b,
	0x6c, 0x98, 0xd3, 0xf3, 0xda, 0x66, 0x9a, 0x4c, 0x00, 0x9c, 0x87, 0x54, 0xdf, 0x67, 0xe7, 0xae,
	0x37, 0x08, 0x6a, 0x66, 0x49, 0x56, 0xa2, 0x4e, 0xa2, 0x90, 0xb0, 0xcc, 0xdd, 0x33, 0x66, 0x0f,
	0x78, 0x6e, 0x5e, 0x9e, 0x8e, 0xb6, 0xc6, 0xc7, 0x30, 0x27, 0xbc, 0xc3, 0x08, 0xd2, 0x15, 0xab,
	0x5e, 0xb2, 0x9a, 0x35, 0xab, 0xbc, 0x63, 0x11, 0xa4, 0xe1, 0x55, 0xc8, 0x5a, 0x75, 0x87, 0x1c,
	0x35, 0xf7, 0xab, 0x3b, 0x3b, 0x47, 0x45, 0xb3, 0xb4, 0x87, 0x12, 0xc6, 0x8f, 0x1a, 0xc0, 0xa4,
	0x48, 0xf0, 0xad, 0x58, 0xd0, 0x28, 0x52, 0x3f, 0xef, 0x3c, 0xe6, 0x44, 0x3c, 0x66, 0x0c, 0x73,
	0x4f, 0xbc, 0xb6, 0x68, 0x3b, 0xe2, 0x40, 0xae, 0xf1, 0x06, 0x80, 0xac, 0x26, 0x71, 0x75, 0x20,
	0x03, 0x9d, 0x27, 0x11, 0xc4, 0xc8, 0x4d, 0x62, 0x25, 0x56, 0xc9, 0x3e, 0xb4, 0xc8, 0x51, 0xd3,
	0x2c, 0x97, 0x91, 0x66, 0xac, 0x40, 0x76, 0x2a, 0xb1, 0x8d, 0x67, 0x90, 0x9d, 0xaa, 0xd5, 0x4b,
	0xe3, 0x40, 0xa0, 0x77, 0x69, 0x4b, 0xc5, 0x20, 0x96, 0xff, 0xdc, 0x7f, 0xe3, 0x2e, 0xe0, 0x8b,
	0xf5, 0x71, 0xd9, 0xad, 0xc6, 0x1d, 0xc8, 0xc4, 0xbb, 0xc2, 0xa5, 0xec, 0x53, 0x58, 0x9b, 0xd5,
	0x04, 0x84, 0xa7, 0x2a, 0xb9, 0x99, 0x10, 0x89, 0xfc, 0x98, 0x00, 0xc6, 0x3d, 0x98, 0x97, 0x3f,
	0x1f, 0xfe, 0x2f, 0xac, 0x3a, 0xb6, 0x63, 0xd6, 0x9a, 0xe5, 0x6a, 0x63, 0xaf, 0x59, 0x32, 0xf7,
	0xcd, 0x52, 0xd5, 0x39, 0x0a, 0x33, 0xa5, 0x42, 0x2c, 0x2b, 0xc4, 0x1b, 0xfb, 0x66, 0xc9, 0x42,
	0x09, 0xe3, 0x01, 0xdc, 0xb8, 0xa2, 0x34, 0x2f, 0xf5, 0xf5, 0xbb, 0x79, 0x48, 0x12, 0x16, 0xf4,
	0xbd, 0x5e, 0xc0, 0xde, 0x7c, 0x0a, 0xbc, 0x0f, 0x0b, 0x01, 0xa7, 0x7c, 0x10, 0xa8, 0x89, 0x96,
	0x12, 0xfd, 0x8a, 0x0f, 0x82, 0x92, 0xd7, 0x66, 0x44, 0x1d, 0xe1, 0x4f, 0x20, 0x1d, 0x4e, 0x82,
	0xd0, 0xba, 0x9a, 0x15, 0xcb, 0xaa, 0x62, 0x43, 0x90, 0xc4, 0x28, 0x72, 0x00, 0xb4, 0x27, 0x0a,
	0x36, 0x1a, 0x00, 0x13, 0x8c, 0x44, 0x09, 0xf8, 0x2e, 0xa4, 0xc3, 0x79, 0xa0, 0x04, 0xb3, 0x26,
	0x46, 0x8c, 0x81, 0x1f, 0x00, 0x9a, 0x4c, 0x02, 0xa5, 0x0a, 0x67, 0xc6, 0x4a, 0x64, 0x66, 0xa8,
	0xbb, 0x2e, 0x50, 0x45, 0xc7, 0x1e, 0x8f, 0x03, 0xa5, 0x3e, 0x51, 0x1d, 0x9b, 0xc4, 0x71, 0x32,
	0x4d, 0xc4, 0x35, 0x58, 0x9f, 0x9a, 0x02, 0xca, 0x42, 0x38, 0x39, 0xae, 0x4d, 0x4f, 0x0e, 0x65,
	0x67, 0xb6, 0x48, 0x04, 0x32, 0x19, 0x09, 0xca, 0xd0, 0x53, 0x15, 0x48, 0x63, 0xea, 0x80, 0x5c,
	0xa0, 0xe2, 0x0a, 0xac, 0xc6, 0xe6, 0x81, 0xb2, 0x10, 0xce, 0x8f, 0xb5, 0xf8, 0xfc, 0x50, 0x46,
	0x66, 0x09, 0xf0, 0x19, 0xe4, 0x5f, 0xdf, 0xf8, 0x95, 0xd1, 0x70, 0x84, 0xdc, 0xbc, 0x64, 0x84,
	0xa8, 0x1b, 0xae, 0x34, 0x65, 0x7c, 0xaf, 0x41, 0x3a, 0x9a, 0x3f, 0x91, 0x4c, 0xd4, 0x5e, 0x9f,
	0x89, 0xd1, 0x02, 0x48, 0xbc, 0xbe, 0x31, 0xea, 0xf1, 0xc6, 0x38, 0x69, 0x1d, 0xda, 0xb8, 0xf5,
	0x5d, 0x83, 0x85, 0x33, 0xfa, 0x5c, 0x74, 0xff, 0xb0, 0xbf, 0xab, 0x1d, 0x2e, 0x00, 0xee, 0xd2,
	0xd6, 0x41, 0xbf, 0x4d, 0x39, 0x73, 0xdc, 0x33, 0x16, 0x70, 0x7a, 0xd6, 0xcf, 0x2d, 0x48, 0xce,
	0x8c, 0x13, 0xe3, 0x04, 0x52, 0x91, 0xa4, 0xfe, 0x17, 0xa3, 0x30, 0x6c, 0x48, 0x45, 0xaa, 0x01,
	0x7f, 0x08, 0x19, 0x51, 0x0f, 0xfb, 0xdd, 0x41, 0xc7, 0xed, 0xd5, 0xe9, 0x19, 0x53, 0xef, 0xc4,
	0x29, 0x54, 0x18, 0xec, 0xd3, 0x61, 0xd7, 0xa3, 0xe1, 0x5d, 0x69, 0x32, 0xda, 0x1a, 0x0d, 0x40,
	0xd3, 0x85, 0xf2, 0xd6, 0xfe, 0x1b, 0x87, 0xb0, 0x3a, 0x23, 0xe5, 0xde, 0xde, 0xee, 0x0b, 0x0d,
	0xb2, 0x53, 0x85, 0xf9, 0x4e, 0x7e, 0xec, 0x2e, 0x6d, 0x15, 0x45, 0x6e, 0x84, 0x6f, 0x84, 0xd1,
	0x16, 0xdf, 0x82, 0xe5, 0x2e, 0x0d, 0xb8, 0xc8, 0xde, 0x61, 0x71, 0x92, 0x3b, 0x71, 0xd0, 0xf8,
	0x5c, 0x83, 0xf5, 0x99, 0xb5, 0xfe, 0x66, 0xae, 0xdd, 0x81, 0x15, 0xee, 0x71, 0xda, 0x2d, 0xbb,
	0xc1, 0x69, 0x89, 0xf6, 0x69, 0x4b, 0x7c, 0x16, 0x24, 0x64, 0xaa, 0x5d, 0x3c, 0x10, 0x2e, 0x1d,
	0xfb, 0x8c, 0x09, 0xac, 0xd1, 0xa7, 0x2d, 0x26, 0x5d, 0xd6, 0x49, 0x1c, 0x34, 0xbe, 0xd5, 0x20,
	0x7f, 0x55, 0x79, 0xbe, 0xfd, 0x0f, 0x57, 0x86, 0xeb, 0xf4, 0x9c, 0xba, 0x5d, 0xfa, 0xc4, 0xed,
	0xba, 0x7c, 0x78, 0xe1, 0x26, 0xf5, 0x73, 0x5e, 0x4e, 0x32, 0x30, 0xa0, 0xe9, 0x06, 0xb7, 0x55,
	0x81, 0xec, 0xd4, 0x17, 0x18, 0xce, 0x42, 0xea, 0xd0, 0x22, 0x8d, 0xaa, 0x5d, 0x6f, 0xda, 0x75,
	0x0b, 0x69, 0x51, 0xc0, 0x79, 0x6c, 0xa3, 0x04, 0x5e, 0x81, 0xe5, 0x31, 0xb0, 0x4b, 0x2c, 0x0b,
	0xe9, 0x5b, 0x5f, 0x69, 0x00, 0x93, 0xa0, 0xf0, 0x22, 0xe8, 0x96, 0xbd, 0x87, 0xfe, 0x83, 0x33,
	0xb0, 0x64, 0xd5, 0x6d, 0xf5, 0x66, 0x7b, 0xa1, 0xe3, 0x65, 0x48, 0x5a, 0x75, 0x5b, 0xbe, 0xdb,
	0xd0, 0x17, 0x3a, 0x4e, 0xc3, 0xa2, 0x55, 0x34, 0xcb, 0xc4, 0x7a, 0x84, 0xbe, 0xd4, 0x71, 0x12,
	0x74, 0xab, 0x6a, 0xa3, 0x5f, 0xc3, 0xd5, 0x81, 0x89, 0x7e, 0xd3, 0x31, 0x82, 0x94, 0x60, 0xa8,
	0xfb, 0xd0, 0xef, 0xa1, 0x46, 0x3e, 0x05, 0xcb, 0xe8, 0x0f, 0x5d, 0x5e, 0x40, 0x2c, 0xb3, 0x6c,
	0xd7, 0x6b, 0x47, 0xe8, 0x4f, 0x1d, 0xaf, 0x03, 0xb2, 0x1c, 0xdb, 0x7e, 0x68, 0xd6, 0x8f, 0x88,
	0xf5, 0xe8, 0xc0, 0x6a, 0x38, 0x0d, 0xf4, 0x97, 0xbe, 0xf5, 0x93, 0x06, 0xcb, 0xb1, 0x8f, 0x47,
	0x9c, 0x01, 0x10, 0xba, 0x66, 0xe8, 0x8b, 0x86, 0x97, 0x61, 0xc9, 0x2c, 0x8f, 0xb6, 0x09, 0xbc,
	0x06, 0x88, 0x98, 0xf5, 0x1d, 0xab, 0x19, 0x21, 0xe9, 0xe2, 0x25, 0x11, 0xa2, 0x13, 0xea, 0x1c,
	0x4e, 0xc2, 0x9c, 0x79, 0xe0, 0xec, 0xa2, 0x79, 0x61, 0xe3, 0x31, 0xa9, 0x3a, 0x56, 0xb3, 0x66,
	0x96, 0xd0, 0x02, 0x4e, 0x43, 0x52, 0xaa, 0xc5, 0x6e, 0x51, 0x68, 0x77, 0x2c, 0xa7, 0x59, 0xb4,
	0xed, 0xbd, 0xaa, 0xd5, 0xac, 0xd6, 0x2b, 0x36, 0x4a, 0x0a, 0x45, 0xc3, 0x31, 0x89, 0xd3, 0x74,
	0x6a, 0x0d, 0xb4, 0x24, 0x5f, 0xb9, 0x36, 0x99, 0xbc, 0x72, 0x01, 0xdf, 0x84, 0xeb, 0x42, 0x55,
	0xab, 0x36, 0x9c, 0xa6, 0x5d, 0x91, 0x77, 0x56, 0xad, 0x86, 0x58, 0x2a, 0x4a, 0xaa, 0x78, 0xfb,
	0xe5, 0xab, 0x0d, 0xed, 0x87, 0x57, 0x1b, 0xda, 0xcf, 0xaf, 0x36, 0x34, 0xf8, 0xbf, 0xe7, 0x77,
	0x0a, 0x22, 0x89, 0x4f, 0x58, 0xe1, 0xc9, 0xf8, 0xdb, 0x3c, 0xfc, 0x26, 0xdf, 0xd5, 0xfe, 0x0e,
	0x00, 0x00, 0xff, 0xff, 0xbb, 0x25, 0xbc, 0x38, 0xb0, 0x0f, 0x00, 0x00,
}

func (m *BKPacketHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BKPacketHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BKPacketHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Priority != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if m.TxnId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("txnId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.TxnId))
		i--
		dAtA[i] = 0x18
	}
	if m.Operation == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("operation")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Operation))
		i--
		dAtA[i] = 0x10
	}
	if m.Version == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("version")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContextPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	} else {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	} else {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RequestContext) > 0 {
		for iNdEx := len(m.RequestContext) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestContext[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xc
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.GetListOfEntriesOfLedgerRequest != nil {
		{
			size, err := m.GetListOfEntriesOfLedgerRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe2
	}
	if m.ForceLedgerRequest != nil {
		{
			size, err := m.ForceLedgerRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xda
	}
	if m.StartTLSRequest != nil {
		{
			size, err := m.StartTLSRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd2
	}
	if m.GetBookieInfoRequest != nil {
		{
			size, err := m.GetBookieInfoRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xca
	}
	if m.ReadLacRequest != nil {
		{
			size, err := m.ReadLacRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	if m.WriteLacRequest != nil {
		{
			size, err := m.WriteLacRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	if m.AuthRequest != nil {
		{
			size, err := m.AuthRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if m.AddRequest != nil {
		{
			size, err := m.AddRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if m.ReadRequest != nil {
		{
			size, err := m.ReadRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Header == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("header")
	} else {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Flag))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.TimeOut != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.TimeOut))
		i--
		dAtA[i] = 0x28
	}
	if m.PreviousLAC != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.PreviousLAC))
		i--
		dAtA[i] = 0x20
	}
	if m.MasterKey != nil {
		i -= len(m.MasterKey)
		copy(dAtA[i:], m.MasterKey)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.MasterKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EntryId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.EntryId))
		i--
		dAtA[i] = 0x10
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Flag))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.WriteFlags != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.WriteFlags))
		i--
		dAtA[i] = 0x28
	}
	if m.Body == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("body")
	} else {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if m.MasterKey == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("masterKey")
	} else {
		i -= len(m.MasterKey)
		copy(dAtA[i:], m.MasterKey)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.MasterKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EntryId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.EntryId))
		i--
		dAtA[i] = 0x10
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StartTLSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTLSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartTLSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *WriteLacRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteLacRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteLacRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Body == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("body")
	} else {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if m.MasterKey == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("masterKey")
	} else {
		i -= len(m.MasterKey)
		copy(dAtA[i:], m.MasterKey)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.MasterKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Lac == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("lac")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Lac))
		i--
		dAtA[i] = 0x10
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForceLedgerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceLedgerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForceLedgerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadLacRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadLacRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadLacRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBookieInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBookieInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBookieInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Requested != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Requested))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetListOfEntriesOfLedgerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetListOfEntriesOfLedgerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetListOfEntriesOfLedgerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GetListOfEntriesOfLedgerResponse != nil {
		{
			size, err := m.GetListOfEntriesOfLedgerResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe2
	}
	if m.ForceLedgerResponse != nil {
		{
			size, err := m.ForceLedgerResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xda
	}
	if m.StartTLSResponse != nil {
		{
			size, err := m.StartTLSResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd2
	}
	if m.GetBookieInfoResponse != nil {
		{
			size, err := m.GetBookieInfoResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xca
	}
	if m.ReadLacResponse != nil {
		{
			size, err := m.ReadLacResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	if m.WriteLacResponse != nil {
		{
			size, err := m.WriteLacResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	if m.AuthResponse != nil {
		{
			size, err := m.AuthResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if m.AddResponse != nil {
		{
			size, err := m.AddResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if m.ReadResponse != nil {
		{
			size, err := m.ReadResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Header == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("header")
	} else {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LacUpdateTimestamp != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LacUpdateTimestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxLAC != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.MaxLAC))
		i--
		dAtA[i] = 0x28
	}
	if m.Body != nil {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if m.EntryId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.EntryId))
		i--
		dAtA[i] = 0x18
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EntryId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.EntryId))
		i--
		dAtA[i] = 0x18
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	} else {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.AuthPluginName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("authPluginName")
	} else {
		i -= len(*m.AuthPluginName)
		copy(dAtA[i:], *m.AuthPluginName)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(*m.AuthPluginName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteLacResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteLacResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteLacResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForceLedgerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceLedgerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForceLedgerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadLacResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadLacResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadLacResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastEntryBody != nil {
		i -= len(m.LastEntryBody)
		copy(dAtA[i:], m.LastEntryBody)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.LastEntryBody)))
		i--
		dAtA[i] = 0x22
	}
	if m.LacBody != nil {
		i -= len(m.LacBody)
		copy(dAtA[i:], m.LacBody)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.LacBody)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBookieInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBookieInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBookieInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FreeDiskSpace != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.FreeDiskSpace))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalDiskCapacity != nil {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.TotalDiskCapacity))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetListOfEntriesOfLedgerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetListOfEntriesOfLedgerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetListOfEntriesOfLedgerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AvailabilityOfEntriesOfLedger != nil {
		i -= len(m.AvailabilityOfEntriesOfLedger)
		copy(dAtA[i:], m.AvailabilityOfEntriesOfLedger)
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(len(m.AvailabilityOfEntriesOfLedger)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LedgerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.LedgerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Status == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	} else {
		i = encodeVarintBookkeeperProtocol(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StartTLSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTLSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartTLSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintBookkeeperProtocol(dAtA []byte, offset int, v uint64) int {
	offset -= sovBookkeeperProtocol(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BKPacketHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Version))
	}
	if m.Operation != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Operation))
	}
	if m.TxnId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.TxnId))
	}
	if m.Priority != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Priority))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContextPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.ReadRequest != nil {
		l = m.ReadRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.AddRequest != nil {
		l = m.AddRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.AuthRequest != nil {
		l = m.AuthRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.WriteLacRequest != nil {
		l = m.WriteLacRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.ReadLacRequest != nil {
		l = m.ReadLacRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.GetBookieInfoRequest != nil {
		l = m.GetBookieInfoRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.StartTLSRequest != nil {
		l = m.StartTLSRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.ForceLedgerRequest != nil {
		l = m.ForceLedgerRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.GetListOfEntriesOfLedgerRequest != nil {
		l = m.GetListOfEntriesOfLedgerRequest.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if len(m.RequestContext) > 0 {
		for _, e := range m.RequestContext {
			l = e.Size()
			n += 2 + l + sovBookkeeperProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.EntryId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.EntryId))
	}
	if m.MasterKey != nil {
		l = len(m.MasterKey)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.PreviousLAC != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.PreviousLAC))
	}
	if m.TimeOut != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.TimeOut))
	}
	if m.Flag != nil {
		n += 2 + sovBookkeeperProtocol(uint64(*m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.EntryId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.EntryId))
	}
	if m.MasterKey != nil {
		l = len(m.MasterKey)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.WriteFlags != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.WriteFlags))
	}
	if m.Flag != nil {
		n += 2 + sovBookkeeperProtocol(uint64(*m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartTLSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteLacRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.Lac != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Lac))
	}
	if m.MasterKey != nil {
		l = len(m.MasterKey)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForceLedgerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadLacRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBookieInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requested != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Requested))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetListOfEntriesOfLedgerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.ReadResponse != nil {
		l = m.ReadResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.AddResponse != nil {
		l = m.AddResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.AuthResponse != nil {
		l = m.AuthResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.WriteLacResponse != nil {
		l = m.WriteLacResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.ReadLacResponse != nil {
		l = m.ReadLacResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.GetBookieInfoResponse != nil {
		l = m.GetBookieInfoResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.StartTLSResponse != nil {
		l = m.StartTLSResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.ForceLedgerResponse != nil {
		l = m.ForceLedgerResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.GetListOfEntriesOfLedgerResponse != nil {
		l = m.GetListOfEntriesOfLedgerResponse.Size()
		n += 2 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.EntryId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.EntryId))
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.MaxLAC != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.MaxLAC))
	}
	if m.LacUpdateTimestamp != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LacUpdateTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.EntryId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.EntryId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthPluginName != nil {
		l = len(*m.AuthPluginName)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteLacResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForceLedgerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadLacResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.LacBody != nil {
		l = len(m.LacBody)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.LastEntryBody != nil {
		l = len(m.LastEntryBody)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBookieInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.TotalDiskCapacity != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.TotalDiskCapacity))
	}
	if m.FreeDiskSpace != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.FreeDiskSpace))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetListOfEntriesOfLedgerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.Status))
	}
	if m.LedgerId != nil {
		n += 1 + sovBookkeeperProtocol(uint64(*m.LedgerId))
	}
	if m.AvailabilityOfEntriesOfLedger != nil {
		l = len(m.AvailabilityOfEntriesOfLedger)
		n += 1 + l + sovBookkeeperProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartTLSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBookkeeperProtocol(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBookkeeperProtocol(x uint64) (n int) {
	return sovBookkeeperProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BKPacketHeader) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BKPacketHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BKPacketHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v ProtocolVersion
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ProtocolVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var v OperationType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operation = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxnId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Priority = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("version")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("operation")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("txnId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextPair) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &BKPacketHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadRequest == nil {
				m.ReadRequest = &ReadRequest{}
			}
			if err := m.ReadRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddRequest == nil {
				m.AddRequest = &AddRequest{}
			}
			if err := m.AddRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthRequest == nil {
				m.AuthRequest = &AuthMessage{}
			}
			if err := m.AuthRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteLacRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteLacRequest == nil {
				m.WriteLacRequest = &WriteLacRequest{}
			}
			if err := m.WriteLacRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadLacRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadLacRequest == nil {
				m.ReadLacRequest = &ReadLacRequest{}
			}
			if err := m.ReadLacRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetBookieInfoRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetBookieInfoRequest == nil {
				m.GetBookieInfoRequest = &GetBookieInfoRequest{}
			}
			if err := m.GetBookieInfoRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTLSRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTLSRequest == nil {
				m.StartTLSRequest = &StartTLSRequest{}
			}
			if err := m.StartTLSRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceLedgerRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForceLedgerRequest == nil {
				m.ForceLedgerRequest = &ForceLedgerRequest{}
			}
			if err := m.ForceLedgerRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetListOfEntriesOfLedgerRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetListOfEntriesOfLedgerRequest == nil {
				m.GetListOfEntriesOfLedgerRequest = &GetListOfEntriesOfLedgerRequest{}
			}
			if err := m.GetListOfEntriesOfLedgerRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 200:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestContext = append(m.RequestContext, &ContextPair{})
			if err := m.RequestContext[len(m.RequestContext)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("header")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterKey = append(m.MasterKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MasterKey == nil {
				m.MasterKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousLAC", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreviousLAC = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeOut", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeOut = &v
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v ReadRequest_Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ReadRequest_Flag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterKey = append(m.MasterKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MasterKey == nil {
				m.MasterKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteFlags", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteFlags = &v
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v AddRequest_Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= AddRequest_Flag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("masterKey")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("body")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTLSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTLSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTLSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteLacRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteLacRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteLacRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lac", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lac = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterKey = append(m.MasterKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MasterKey == nil {
				m.MasterKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lac")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("masterKey")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("body")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceLedgerRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceLedgerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceLedgerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadLacRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadLacRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadLacRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBookieInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBookieInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBookieInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requested", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Requested = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetListOfEntriesOfLedgerRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetListOfEntriesOfLedgerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetListOfEntriesOfLedgerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &BKPacketHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000002)
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadResponse == nil {
				m.ReadResponse = &ReadResponse{}
			}
			if err := m.ReadResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddResponse == nil {
				m.AddResponse = &AddResponse{}
			}
			if err := m.AddResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthResponse == nil {
				m.AuthResponse = &AuthMessage{}
			}
			if err := m.AuthResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteLacResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteLacResponse == nil {
				m.WriteLacResponse = &WriteLacResponse{}
			}
			if err := m.WriteLacResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadLacResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadLacResponse == nil {
				m.ReadLacResponse = &ReadLacResponse{}
			}
			if err := m.ReadLacResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetBookieInfoResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetBookieInfoResponse == nil {
				m.GetBookieInfoResponse = &GetBookieInfoResponse{}
			}
			if err := m.GetBookieInfoResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTLSResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTLSResponse == nil {
				m.StartTLSResponse = &StartTLSResponse{}
			}
			if err := m.StartTLSResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceLedgerResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForceLedgerResponse == nil {
				m.ForceLedgerResponse = &ForceLedgerResponse{}
			}
			if err := m.ForceLedgerResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetListOfEntriesOfLedgerResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetListOfEntriesOfLedgerResponse == nil {
				m.GetListOfEntriesOfLedgerResponse = &GetListOfEntriesOfLedgerResponse{}
			}
			if err := m.GetListOfEntriesOfLedgerResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("header")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLAC", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxLAC = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacUpdateTimestamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LacUpdateTimestamp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryId = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("entryId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPluginName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AuthPluginName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("authPluginName")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteLacResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteLacResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteLacResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceLedgerResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceLedgerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceLedgerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadLacResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadLacResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadLacResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LacBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LacBody = append(m.LacBody[:0], dAtA[iNdEx:postIndex]...)
			if m.LacBody == nil {
				m.LacBody = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEntryBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastEntryBody = append(m.LastEntryBody[:0], dAtA[iNdEx:postIndex]...)
			if m.LastEntryBody == nil {
				m.LastEntryBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBookieInfoResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBookieInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBookieInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDiskCapacity", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDiskCapacity = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeDiskSpace", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FreeDiskSpace = &v
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetListOfEntriesOfLedgerResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetListOfEntriesOfLedgerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetListOfEntriesOfLedgerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v StatusCode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityOfEntriesOfLedger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityOfEntriesOfLedger = append(m.AvailabilityOfEntriesOfLedger[:0], dAtA[iNdEx:postIndex]...)
			if m.AvailabilityOfEntriesOfLedger == nil {
				m.AvailabilityOfEntriesOfLedger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTLSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTLSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTLSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBookkeeperProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBookkeeperProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBookkeeperProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBookkeeperProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBookkeeperProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBookkeeperProtocol
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBookkeeperProtocol
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBookkeeperProtocol
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBookkeeperProtocol        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBookkeeperProtocol          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBookkeeperProtocol = fmt.Errorf("proto: unexpected end of group")
)
