// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: DataFormats.proto

package DataFormats

import (
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LedgerMetadataFormat_State int32

const (
	LedgerMetadataFormat_OPEN        LedgerMetadataFormat_State = 1
	LedgerMetadataFormat_IN_RECOVERY LedgerMetadataFormat_State = 2
	LedgerMetadataFormat_CLOSED      LedgerMetadataFormat_State = 3
)

var LedgerMetadataFormat_State_name = map[int32]string{
	1: "OPEN",
	2: "IN_RECOVERY",
	3: "CLOSED",
}

var LedgerMetadataFormat_State_value = map[string]int32{
	"OPEN":        1,
	"IN_RECOVERY": 2,
	"CLOSED":      3,
}

func (x LedgerMetadataFormat_State) Enum() *LedgerMetadataFormat_State {
	p := new(LedgerMetadataFormat_State)
	*p = x
	return p
}

func (x LedgerMetadataFormat_State) String() string {
	return proto.EnumName(LedgerMetadataFormat_State_name, int32(x))
}

func (x *LedgerMetadataFormat_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LedgerMetadataFormat_State_value, data, "LedgerMetadataFormat_State")
	if err != nil {
		return err
	}
	*x = LedgerMetadataFormat_State(value)
	return nil
}

func (LedgerMetadataFormat_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{0, 0}
}

type LedgerMetadataFormat_DigestType int32

const (
	LedgerMetadataFormat_CRC32  LedgerMetadataFormat_DigestType = 1
	LedgerMetadataFormat_HMAC   LedgerMetadataFormat_DigestType = 2
	LedgerMetadataFormat_CRC32C LedgerMetadataFormat_DigestType = 3
	LedgerMetadataFormat_DUMMY  LedgerMetadataFormat_DigestType = 4
)

var LedgerMetadataFormat_DigestType_name = map[int32]string{
	1: "CRC32",
	2: "HMAC",
	3: "CRC32C",
	4: "DUMMY",
}

var LedgerMetadataFormat_DigestType_value = map[string]int32{
	"CRC32":  1,
	"HMAC":   2,
	"CRC32C": 3,
	"DUMMY":  4,
}

func (x LedgerMetadataFormat_DigestType) Enum() *LedgerMetadataFormat_DigestType {
	p := new(LedgerMetadataFormat_DigestType)
	*p = x
	return p
}

func (x LedgerMetadataFormat_DigestType) String() string {
	return proto.EnumName(LedgerMetadataFormat_DigestType_name, int32(x))
}

func (x *LedgerMetadataFormat_DigestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LedgerMetadataFormat_DigestType_value, data, "LedgerMetadataFormat_DigestType")
	if err != nil {
		return err
	}
	*x = LedgerMetadataFormat_DigestType(value)
	return nil
}

func (LedgerMetadataFormat_DigestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{0, 1}
}

//*
// Metadata format for storing ledger information
type LedgerMetadataFormat struct {
	QuorumSize           *int32                                   `protobuf:"varint,1,req,name=quorumSize" json:"quorumSize,omitempty"`
	EnsembleSize         *int32                                   `protobuf:"varint,2,req,name=ensembleSize" json:"ensembleSize,omitempty"`
	Length               *int64                                   `protobuf:"varint,3,req,name=length" json:"length,omitempty"`
	LastEntryId          *int64                                   `protobuf:"varint,4,opt,name=lastEntryId" json:"lastEntryId,omitempty"`
	State                *LedgerMetadataFormat_State              `protobuf:"varint,5,req,name=state,enum=LedgerMetadataFormat_State,def=1" json:"state,omitempty"`
	Segment              []*LedgerMetadataFormat_Segment          `protobuf:"bytes,6,rep,name=segment" json:"segment,omitempty"`
	DigestType           *LedgerMetadataFormat_DigestType         `protobuf:"varint,7,opt,name=digestType,enum=LedgerMetadataFormat_DigestType" json:"digestType,omitempty"`
	Password             []byte                                   `protobuf:"bytes,8,opt,name=password" json:"password,omitempty"`
	AckQuorumSize        *int32                                   `protobuf:"varint,9,opt,name=ackQuorumSize" json:"ackQuorumSize,omitempty"`
	Ctime                *int64                                   `protobuf:"varint,10,opt,name=ctime" json:"ctime,omitempty"`
	CustomMetadata       []*LedgerMetadataFormatCMetadataMapEntry `protobuf:"bytes,11,rep,name=customMetadata" json:"customMetadata,omitempty"`
	CToken               *int64                                   `protobuf:"varint,12,opt,name=cToken" json:"cToken,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *LedgerMetadataFormat) Reset()         { *m = LedgerMetadataFormat{} }
func (m *LedgerMetadataFormat) String() string { return proto.CompactTextString(m) }
func (*LedgerMetadataFormat) ProtoMessage()    {}
func (*LedgerMetadataFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{0}
}
func (m *LedgerMetadataFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerMetadataFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerMetadataFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerMetadataFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerMetadataFormat.Merge(m, src)
}
func (m *LedgerMetadataFormat) XXX_Size() int {
	return m.Size()
}
func (m *LedgerMetadataFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerMetadataFormat.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerMetadataFormat proto.InternalMessageInfo

const Default_LedgerMetadataFormat_State LedgerMetadataFormat_State = LedgerMetadataFormat_OPEN

func (m *LedgerMetadataFormat) GetQuorumSize() int32 {
	if m != nil && m.QuorumSize != nil {
		return *m.QuorumSize
	}
	return 0
}

func (m *LedgerMetadataFormat) GetEnsembleSize() int32 {
	if m != nil && m.EnsembleSize != nil {
		return *m.EnsembleSize
	}
	return 0
}

func (m *LedgerMetadataFormat) GetLength() int64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *LedgerMetadataFormat) GetLastEntryId() int64 {
	if m != nil && m.LastEntryId != nil {
		return *m.LastEntryId
	}
	return 0
}

func (m *LedgerMetadataFormat) GetState() LedgerMetadataFormat_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_LedgerMetadataFormat_State
}

func (m *LedgerMetadataFormat) GetSegment() []*LedgerMetadataFormat_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *LedgerMetadataFormat) GetDigestType() LedgerMetadataFormat_DigestType {
	if m != nil && m.DigestType != nil {
		return *m.DigestType
	}
	return LedgerMetadataFormat_CRC32
}

func (m *LedgerMetadataFormat) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *LedgerMetadataFormat) GetAckQuorumSize() int32 {
	if m != nil && m.AckQuorumSize != nil {
		return *m.AckQuorumSize
	}
	return 0
}

func (m *LedgerMetadataFormat) GetCtime() int64 {
	if m != nil && m.Ctime != nil {
		return *m.Ctime
	}
	return 0
}

func (m *LedgerMetadataFormat) GetCustomMetadata() []*LedgerMetadataFormatCMetadataMapEntry {
	if m != nil {
		return m.CustomMetadata
	}
	return nil
}

func (m *LedgerMetadataFormat) GetCToken() int64 {
	if m != nil && m.CToken != nil {
		return *m.CToken
	}
	return 0
}

type LedgerMetadataFormat_Segment struct {
	EnsembleMember       []string `protobuf:"bytes,1,rep,name=ensembleMember" json:"ensembleMember,omitempty"`
	FirstEntryId         *int64   `protobuf:"varint,2,req,name=firstEntryId" json:"firstEntryId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LedgerMetadataFormat_Segment) Reset()         { *m = LedgerMetadataFormat_Segment{} }
func (m *LedgerMetadataFormat_Segment) String() string { return proto.CompactTextString(m) }
func (*LedgerMetadataFormat_Segment) ProtoMessage()    {}
func (*LedgerMetadataFormat_Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{0, 0}
}
func (m *LedgerMetadataFormat_Segment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerMetadataFormat_Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerMetadataFormat_Segment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerMetadataFormat_Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerMetadataFormat_Segment.Merge(m, src)
}
func (m *LedgerMetadataFormat_Segment) XXX_Size() int {
	return m.Size()
}
func (m *LedgerMetadataFormat_Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerMetadataFormat_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerMetadataFormat_Segment proto.InternalMessageInfo

func (m *LedgerMetadataFormat_Segment) GetEnsembleMember() []string {
	if m != nil {
		return m.EnsembleMember
	}
	return nil
}

func (m *LedgerMetadataFormat_Segment) GetFirstEntryId() int64 {
	if m != nil && m.FirstEntryId != nil {
		return *m.FirstEntryId
	}
	return 0
}

type LedgerMetadataFormatCMetadataMapEntry struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LedgerMetadataFormatCMetadataMapEntry) Reset()         { *m = LedgerMetadataFormatCMetadataMapEntry{} }
func (m *LedgerMetadataFormatCMetadataMapEntry) String() string { return proto.CompactTextString(m) }
func (*LedgerMetadataFormatCMetadataMapEntry) ProtoMessage()    {}
func (*LedgerMetadataFormatCMetadataMapEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{0, 1}
}
func (m *LedgerMetadataFormatCMetadataMapEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerMetadataFormatCMetadataMapEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerMetadataFormatCMetadataMapEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerMetadataFormatCMetadataMapEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerMetadataFormatCMetadataMapEntry.Merge(m, src)
}
func (m *LedgerMetadataFormatCMetadataMapEntry) XXX_Size() int {
	return m.Size()
}
func (m *LedgerMetadataFormatCMetadataMapEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerMetadataFormatCMetadataMapEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerMetadataFormatCMetadataMapEntry proto.InternalMessageInfo

func (m *LedgerMetadataFormatCMetadataMapEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *LedgerMetadataFormatCMetadataMapEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type LedgerRereplicationLayoutFormat struct {
	Type                 *string  `protobuf:"bytes,1,req,name=type" json:"type,omitempty"`
	Version              *int32   `protobuf:"varint,2,req,name=version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LedgerRereplicationLayoutFormat) Reset()         { *m = LedgerRereplicationLayoutFormat{} }
func (m *LedgerRereplicationLayoutFormat) String() string { return proto.CompactTextString(m) }
func (*LedgerRereplicationLayoutFormat) ProtoMessage()    {}
func (*LedgerRereplicationLayoutFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{1}
}
func (m *LedgerRereplicationLayoutFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerRereplicationLayoutFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerRereplicationLayoutFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerRereplicationLayoutFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerRereplicationLayoutFormat.Merge(m, src)
}
func (m *LedgerRereplicationLayoutFormat) XXX_Size() int {
	return m.Size()
}
func (m *LedgerRereplicationLayoutFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerRereplicationLayoutFormat.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerRereplicationLayoutFormat proto.InternalMessageInfo

func (m *LedgerRereplicationLayoutFormat) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *LedgerRereplicationLayoutFormat) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

type UnderreplicatedLedgerFormat struct {
	Replica              []string `protobuf:"bytes,1,rep,name=replica" json:"replica,omitempty"`
	Ctime                *int64   `protobuf:"varint,2,opt,name=ctime" json:"ctime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnderreplicatedLedgerFormat) Reset()         { *m = UnderreplicatedLedgerFormat{} }
func (m *UnderreplicatedLedgerFormat) String() string { return proto.CompactTextString(m) }
func (*UnderreplicatedLedgerFormat) ProtoMessage()    {}
func (*UnderreplicatedLedgerFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{2}
}
func (m *UnderreplicatedLedgerFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnderreplicatedLedgerFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnderreplicatedLedgerFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnderreplicatedLedgerFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnderreplicatedLedgerFormat.Merge(m, src)
}
func (m *UnderreplicatedLedgerFormat) XXX_Size() int {
	return m.Size()
}
func (m *UnderreplicatedLedgerFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_UnderreplicatedLedgerFormat.DiscardUnknown(m)
}

var xxx_messageInfo_UnderreplicatedLedgerFormat proto.InternalMessageInfo

func (m *UnderreplicatedLedgerFormat) GetReplica() []string {
	if m != nil {
		return m.Replica
	}
	return nil
}

func (m *UnderreplicatedLedgerFormat) GetCtime() int64 {
	if m != nil && m.Ctime != nil {
		return *m.Ctime
	}
	return 0
}

//*
// Cookie format for storing cookie information
type CookieFormat struct {
	BookieHost           *string  `protobuf:"bytes,1,req,name=bookieHost" json:"bookieHost,omitempty"`
	JournalDir           *string  `protobuf:"bytes,2,req,name=journalDir" json:"journalDir,omitempty"`
	LedgerDirs           *string  `protobuf:"bytes,3,req,name=ledgerDirs" json:"ledgerDirs,omitempty"`
	InstanceId           *string  `protobuf:"bytes,4,opt,name=instanceId" json:"instanceId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CookieFormat) Reset()         { *m = CookieFormat{} }
func (m *CookieFormat) String() string { return proto.CompactTextString(m) }
func (*CookieFormat) ProtoMessage()    {}
func (*CookieFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{3}
}
func (m *CookieFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CookieFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CookieFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieFormat.Merge(m, src)
}
func (m *CookieFormat) XXX_Size() int {
	return m.Size()
}
func (m *CookieFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieFormat.DiscardUnknown(m)
}

var xxx_messageInfo_CookieFormat proto.InternalMessageInfo

func (m *CookieFormat) GetBookieHost() string {
	if m != nil && m.BookieHost != nil {
		return *m.BookieHost
	}
	return ""
}

func (m *CookieFormat) GetJournalDir() string {
	if m != nil && m.JournalDir != nil {
		return *m.JournalDir
	}
	return ""
}

func (m *CookieFormat) GetLedgerDirs() string {
	if m != nil && m.LedgerDirs != nil {
		return *m.LedgerDirs
	}
	return ""
}

func (m *CookieFormat) GetInstanceId() string {
	if m != nil && m.InstanceId != nil {
		return *m.InstanceId
	}
	return ""
}

//*
// Debug information for locks
type LockDataFormat struct {
	BookieId             *string  `protobuf:"bytes,1,opt,name=bookieId" json:"bookieId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockDataFormat) Reset()         { *m = LockDataFormat{} }
func (m *LockDataFormat) String() string { return proto.CompactTextString(m) }
func (*LockDataFormat) ProtoMessage()    {}
func (*LockDataFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{4}
}
func (m *LockDataFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockDataFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockDataFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockDataFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockDataFormat.Merge(m, src)
}
func (m *LockDataFormat) XXX_Size() int {
	return m.Size()
}
func (m *LockDataFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_LockDataFormat.DiscardUnknown(m)
}

var xxx_messageInfo_LockDataFormat proto.InternalMessageInfo

func (m *LockDataFormat) GetBookieId() string {
	if m != nil && m.BookieId != nil {
		return *m.BookieId
	}
	return ""
}

//*
// Debug information for auditor votes
type AuditorVoteFormat struct {
	BookieId             *string  `protobuf:"bytes,1,opt,name=bookieId" json:"bookieId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuditorVoteFormat) Reset()         { *m = AuditorVoteFormat{} }
func (m *AuditorVoteFormat) String() string { return proto.CompactTextString(m) }
func (*AuditorVoteFormat) ProtoMessage()    {}
func (*AuditorVoteFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{5}
}
func (m *AuditorVoteFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditorVoteFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditorVoteFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditorVoteFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditorVoteFormat.Merge(m, src)
}
func (m *AuditorVoteFormat) XXX_Size() int {
	return m.Size()
}
func (m *AuditorVoteFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditorVoteFormat.DiscardUnknown(m)
}

var xxx_messageInfo_AuditorVoteFormat proto.InternalMessageInfo

func (m *AuditorVoteFormat) GetBookieId() string {
	if m != nil && m.BookieId != nil {
		return *m.BookieId
	}
	return ""
}

//*
// information of checkAllLedgers execution
type CheckAllLedgersFormat struct {
	CheckAllLedgersCTime *int64   `protobuf:"varint,1,opt,name=checkAllLedgersCTime" json:"checkAllLedgersCTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckAllLedgersFormat) Reset()         { *m = CheckAllLedgersFormat{} }
func (m *CheckAllLedgersFormat) String() string { return proto.CompactTextString(m) }
func (*CheckAllLedgersFormat) ProtoMessage()    {}
func (*CheckAllLedgersFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{6}
}
func (m *CheckAllLedgersFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckAllLedgersFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckAllLedgersFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckAllLedgersFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAllLedgersFormat.Merge(m, src)
}
func (m *CheckAllLedgersFormat) XXX_Size() int {
	return m.Size()
}
func (m *CheckAllLedgersFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAllLedgersFormat.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAllLedgersFormat proto.InternalMessageInfo

func (m *CheckAllLedgersFormat) GetCheckAllLedgersCTime() int64 {
	if m != nil && m.CheckAllLedgersCTime != nil {
		return *m.CheckAllLedgersCTime
	}
	return 0
}

//*
// information of PlacementPolicyCheck execution
type PlacementPolicyCheckFormat struct {
	PlacementPolicyCheckCTime *int64   `protobuf:"varint,1,opt,name=placementPolicyCheckCTime" json:"placementPolicyCheckCTime,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *PlacementPolicyCheckFormat) Reset()         { *m = PlacementPolicyCheckFormat{} }
func (m *PlacementPolicyCheckFormat) String() string { return proto.CompactTextString(m) }
func (*PlacementPolicyCheckFormat) ProtoMessage()    {}
func (*PlacementPolicyCheckFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{7}
}
func (m *PlacementPolicyCheckFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementPolicyCheckFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementPolicyCheckFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementPolicyCheckFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementPolicyCheckFormat.Merge(m, src)
}
func (m *PlacementPolicyCheckFormat) XXX_Size() int {
	return m.Size()
}
func (m *PlacementPolicyCheckFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementPolicyCheckFormat.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementPolicyCheckFormat proto.InternalMessageInfo

func (m *PlacementPolicyCheckFormat) GetPlacementPolicyCheckCTime() int64 {
	if m != nil && m.PlacementPolicyCheckCTime != nil {
		return *m.PlacementPolicyCheckCTime
	}
	return 0
}

//*
// information of ReplicasCheck execution
type ReplicasCheckFormat struct {
	ReplicasCheckCTime   *int64   `protobuf:"varint,1,opt,name=replicasCheckCTime" json:"replicasCheckCTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicasCheckFormat) Reset()         { *m = ReplicasCheckFormat{} }
func (m *ReplicasCheckFormat) String() string { return proto.CompactTextString(m) }
func (*ReplicasCheckFormat) ProtoMessage()    {}
func (*ReplicasCheckFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{8}
}
func (m *ReplicasCheckFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicasCheckFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicasCheckFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicasCheckFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicasCheckFormat.Merge(m, src)
}
func (m *ReplicasCheckFormat) XXX_Size() int {
	return m.Size()
}
func (m *ReplicasCheckFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicasCheckFormat.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicasCheckFormat proto.InternalMessageInfo

func (m *ReplicasCheckFormat) GetReplicasCheckCTime() int64 {
	if m != nil && m.ReplicasCheckCTime != nil {
		return *m.ReplicasCheckCTime
	}
	return 0
}

//*
// information about services exposed by a Bookie.
type BookieServiceInfoFormat struct {
	Endpoints            []*BookieServiceInfoFormat_Endpoint `protobuf:"bytes,6,rep,name=endpoints" json:"endpoints,omitempty"`
	Properties           map[string]string                   `protobuf:"bytes,7,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *BookieServiceInfoFormat) Reset()         { *m = BookieServiceInfoFormat{} }
func (m *BookieServiceInfoFormat) String() string { return proto.CompactTextString(m) }
func (*BookieServiceInfoFormat) ProtoMessage()    {}
func (*BookieServiceInfoFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{9}
}
func (m *BookieServiceInfoFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BookieServiceInfoFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BookieServiceInfoFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BookieServiceInfoFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BookieServiceInfoFormat.Merge(m, src)
}
func (m *BookieServiceInfoFormat) XXX_Size() int {
	return m.Size()
}
func (m *BookieServiceInfoFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_BookieServiceInfoFormat.DiscardUnknown(m)
}

var xxx_messageInfo_BookieServiceInfoFormat proto.InternalMessageInfo

func (m *BookieServiceInfoFormat) GetEndpoints() []*BookieServiceInfoFormat_Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *BookieServiceInfoFormat) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

//*
// Information about an endpoint.
type BookieServiceInfoFormat_Endpoint struct {
	Id                   *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Port                 *int32   `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	Host                 *string  `protobuf:"bytes,3,req,name=host" json:"host,omitempty"`
	Protocol             *string  `protobuf:"bytes,4,req,name=protocol" json:"protocol,omitempty"`
	Auth                 []string `protobuf:"bytes,5,rep,name=auth" json:"auth,omitempty"`
	Extensions           []string `protobuf:"bytes,6,rep,name=extensions" json:"extensions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BookieServiceInfoFormat_Endpoint) Reset()         { *m = BookieServiceInfoFormat_Endpoint{} }
func (m *BookieServiceInfoFormat_Endpoint) String() string { return proto.CompactTextString(m) }
func (*BookieServiceInfoFormat_Endpoint) ProtoMessage()    {}
func (*BookieServiceInfoFormat_Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_38ce640af007ee02, []int{9, 0}
}
func (m *BookieServiceInfoFormat_Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BookieServiceInfoFormat_Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BookieServiceInfoFormat_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BookieServiceInfoFormat_Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BookieServiceInfoFormat_Endpoint.Merge(m, src)
}
func (m *BookieServiceInfoFormat_Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *BookieServiceInfoFormat_Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_BookieServiceInfoFormat_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_BookieServiceInfoFormat_Endpoint proto.InternalMessageInfo

func (m *BookieServiceInfoFormat_Endpoint) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BookieServiceInfoFormat_Endpoint) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *BookieServiceInfoFormat_Endpoint) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *BookieServiceInfoFormat_Endpoint) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *BookieServiceInfoFormat_Endpoint) GetAuth() []string {
	if m != nil {
		return m.Auth
	}
	return nil
}

func (m *BookieServiceInfoFormat_Endpoint) GetExtensions() []string {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func init() {
	proto.RegisterEnum("LedgerMetadataFormat_State", LedgerMetadataFormat_State_name, LedgerMetadataFormat_State_value)
	proto.RegisterEnum("LedgerMetadataFormat_DigestType", LedgerMetadataFormat_DigestType_name, LedgerMetadataFormat_DigestType_value)
	proto.RegisterType((*LedgerMetadataFormat)(nil), "LedgerMetadataFormat")
	proto.RegisterType((*LedgerMetadataFormat_Segment)(nil), "LedgerMetadataFormat.Segment")
	proto.RegisterType((*LedgerMetadataFormatCMetadataMapEntry)(nil), "LedgerMetadataFormat.cMetadataMapEntry")
	proto.RegisterType((*LedgerRereplicationLayoutFormat)(nil), "LedgerRereplicationLayoutFormat")
	proto.RegisterType((*UnderreplicatedLedgerFormat)(nil), "UnderreplicatedLedgerFormat")
	proto.RegisterType((*CookieFormat)(nil), "CookieFormat")
	proto.RegisterType((*LockDataFormat)(nil), "LockDataFormat")
	proto.RegisterType((*AuditorVoteFormat)(nil), "AuditorVoteFormat")
	proto.RegisterType((*CheckAllLedgersFormat)(nil), "CheckAllLedgersFormat")
	proto.RegisterType((*PlacementPolicyCheckFormat)(nil), "PlacementPolicyCheckFormat")
	proto.RegisterType((*ReplicasCheckFormat)(nil), "ReplicasCheckFormat")
	proto.RegisterType((*BookieServiceInfoFormat)(nil), "BookieServiceInfoFormat")
	proto.RegisterMapType((map[string]string)(nil), "BookieServiceInfoFormat.PropertiesEntry")
	proto.RegisterType((*BookieServiceInfoFormat_Endpoint)(nil), "BookieServiceInfoFormat.Endpoint")
}

func init() { proto.RegisterFile("DataFormats.proto", fileDescriptor_38ce640af007ee02) }

var fileDescriptor_38ce640af007ee02 = []byte{
	// 890 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x51, 0x6f, 0xe3, 0x44,
	0x10, 0x96, 0x9d, 0xa6, 0xa9, 0xa7, 0x25, 0x97, 0x2e, 0x05, 0x4c, 0x2a, 0x8a, 0xb1, 0x10, 0x58,
	0x02, 0x05, 0x29, 0x3c, 0xdc, 0xe9, 0x00, 0x41, 0x2f, 0x09, 0x6a, 0x45, 0x73, 0x29, 0xdb, 0xf6,
	0xa4, 0xe3, 0x05, 0x6d, 0xed, 0xb9, 0x64, 0x89, 0xe3, 0x35, 0xeb, 0x4d, 0x21, 0xfc, 0x01, 0xde,
	0x78, 0xe0, 0x57, 0xf1, 0xc8, 0x4f, 0x40, 0xfd, 0x15, 0x3c, 0xa2, 0x5d, 0x6f, 0x12, 0xb7, 0xa4,
	0x82, 0xb7, 0x9d, 0x6f, 0xbe, 0x19, 0xcf, 0xce, 0xcc, 0xb7, 0x86, 0xfd, 0x3e, 0x53, 0xec, 0x6b,
	0x21, 0x67, 0x4c, 0x15, 0x9d, 0x5c, 0x0a, 0x25, 0xc2, 0x5f, 0xb7, 0xe1, 0xe0, 0x0c, 0x93, 0x31,
	0xca, 0x21, 0x2a, 0x96, 0xac, 0xfc, 0xe4, 0x08, 0xe0, 0xc7, 0xb9, 0x90, 0xf3, 0xd9, 0x05, 0xff,
	0x05, 0x7d, 0x27, 0x70, 0xa3, 0x3a, 0xad, 0x20, 0x24, 0x84, 0x3d, 0xcc, 0x0a, 0x9c, 0x5d, 0xa7,
	0x68, 0x18, 0xae, 0x61, 0xdc, 0xc1, 0xc8, 0x9b, 0xb0, 0x9d, 0x62, 0x36, 0x56, 0x13, 0xbf, 0x16,
	0xb8, 0x51, 0x8d, 0x5a, 0x8b, 0x04, 0xb0, 0x9b, 0xb2, 0x42, 0x0d, 0x32, 0x25, 0x17, 0xa7, 0x89,
	0xbf, 0x15, 0x38, 0x51, 0x8d, 0x56, 0x21, 0xf2, 0x18, 0xea, 0x85, 0x62, 0x0a, 0xfd, 0x7a, 0xe0,
	0x46, 0xcd, 0xee, 0x61, 0x67, 0x53, 0x8d, 0x9d, 0x0b, 0x4d, 0x79, 0xba, 0x35, 0x3a, 0x1f, 0x3c,
	0xa7, 0x25, 0x9f, 0x3c, 0x86, 0x46, 0x81, 0xe3, 0x19, 0x66, 0xca, 0xdf, 0x0e, 0x6a, 0xd1, 0x6e,
	0xf7, 0x9d, 0x07, 0x42, 0x4b, 0x12, 0x5d, 0xb2, 0xc9, 0x57, 0x00, 0x09, 0x1f, 0x63, 0xa1, 0x2e,
	0x17, 0x39, 0xfa, 0x8d, 0xc0, 0x89, 0x9a, 0xdd, 0x60, 0x73, 0x6c, 0x7f, 0xc5, 0xa3, 0x95, 0x18,
	0xd2, 0x86, 0x9d, 0x9c, 0x15, 0xc5, 0x4f, 0x42, 0x26, 0xfe, 0x4e, 0xe0, 0x44, 0x7b, 0x74, 0x65,
	0x93, 0xf7, 0xe1, 0x35, 0x16, 0x4f, 0xbf, 0x5d, 0x37, 0xd4, 0x0b, 0x9c, 0xa8, 0x4e, 0xef, 0x82,
	0xe4, 0x00, 0xea, 0xb1, 0xe2, 0x33, 0xf4, 0xc1, 0x74, 0xa4, 0x34, 0xc8, 0x08, 0x9a, 0xf1, 0xbc,
	0x50, 0x62, 0xb6, 0x2c, 0xc3, 0xdf, 0x35, 0x37, 0xfb, 0x70, 0x73, 0x75, 0xf1, 0xd2, 0x1e, 0xb2,
	0xdc, 0xb4, 0x93, 0xde, 0x0b, 0xd7, 0x63, 0x89, 0x2f, 0xc5, 0x14, 0x33, 0x7f, 0xcf, 0x7c, 0xc7,
	0x5a, 0xed, 0x2b, 0x68, 0xd8, 0xb6, 0x90, 0x0f, 0xa0, 0xb9, 0x9c, 0xe4, 0x10, 0x67, 0xd7, 0x28,
	0x7d, 0x27, 0xa8, 0x45, 0x1e, 0xbd, 0x87, 0xea, 0x2d, 0x78, 0xc5, 0xe5, 0x7a, 0x94, 0xae, 0x99,
	0xf3, 0x1d, 0xac, 0xfd, 0x19, 0xec, 0xff, 0xab, 0x26, 0xd2, 0x82, 0xda, 0x14, 0x17, 0xbe, 0x13,
	0x38, 0x91, 0x47, 0xf5, 0x51, 0x5f, 0xfe, 0x86, 0xa5, 0x73, 0xbd, 0x49, 0xba, 0x77, 0xa5, 0x11,
	0x76, 0xa0, 0x6e, 0xa6, 0x4c, 0x76, 0xc0, 0xcc, 0xb9, 0xe5, 0x90, 0x47, 0xb0, 0x7b, 0xfa, 0xfc,
	0x7b, 0x3a, 0xe8, 0x8d, 0x5e, 0x0c, 0xe8, 0xcb, 0x96, 0x4b, 0x00, 0xb6, 0x7b, 0x67, 0xa3, 0x8b,
	0x41, 0xbf, 0x55, 0x0b, 0x9f, 0x00, 0xac, 0xc7, 0x43, 0x3c, 0xa8, 0xf7, 0x68, 0xef, 0xd3, 0x6e,
	0xcb, 0xd1, 0xf1, 0x27, 0xc3, 0xe3, 0x9e, 0xa5, 0x6b, 0xb0, 0xd7, 0xaa, 0x69, 0x42, 0xff, 0x6a,
	0x38, 0x7c, 0xd9, 0xda, 0x0a, 0x47, 0xf0, 0x6e, 0xd9, 0x4f, 0x8a, 0x12, 0xf3, 0x94, 0xc7, 0x4c,
	0x71, 0x91, 0x9d, 0xb1, 0x85, 0x98, 0x2b, 0xab, 0x09, 0x02, 0x5b, 0x4a, 0x6f, 0x87, 0x56, 0x83,
	0x47, 0xcd, 0x99, 0xf8, 0xd0, 0xb8, 0x41, 0x59, 0x70, 0x91, 0x59, 0x09, 0x2c, 0xcd, 0x70, 0x08,
	0x87, 0x57, 0x59, 0x82, 0x72, 0x99, 0x0d, 0x93, 0x32, 0xbf, 0x4d, 0xe6, 0x43, 0xc3, 0x7a, 0x6c,
	0x6f, 0x97, 0xe6, 0x7a, 0x0d, 0xdc, 0xca, 0x1a, 0x84, 0xbf, 0x39, 0xb0, 0xd7, 0x13, 0x62, 0xca,
	0x71, 0xad, 0xd0, 0x6b, 0x63, 0x9f, 0x88, 0x42, 0xd9, 0x9a, 0x2a, 0x88, 0xf6, 0xff, 0x20, 0xe6,
	0x32, 0x63, 0x69, 0x9f, 0x4b, 0x53, 0x9c, 0x47, 0x2b, 0x88, 0xf6, 0xa7, 0xa6, 0xa0, 0x3e, 0x97,
	0x85, 0x51, 0xa8, 0x47, 0x2b, 0x88, 0xf6, 0xf3, 0xac, 0x50, 0x2c, 0x8b, 0xd1, 0x8a, 0xd4, 0xa3,
	0x15, 0x24, 0xfc, 0x18, 0x9a, 0x67, 0x22, 0x9e, 0xae, 0xdf, 0x14, 0xad, 0x80, 0xf2, 0xfb, 0xa7,
	0x89, 0x9d, 0xec, 0xca, 0x0e, 0x3f, 0x81, 0xfd, 0xe3, 0x79, 0xc2, 0x95, 0x90, 0x2f, 0x84, 0xc2,
	0xff, 0x11, 0xf0, 0x0d, 0xbc, 0xd1, 0x9b, 0x60, 0x3c, 0x3d, 0x4e, 0xd3, 0xb2, 0x6f, 0x85, 0x0d,
	0xea, 0xc2, 0x41, 0x7c, 0xd7, 0xd1, 0xbb, 0xd4, 0xdd, 0x72, 0x4c, 0xb7, 0x36, 0xfa, 0xc2, 0xef,
	0xa0, 0x7d, 0x9e, 0xb2, 0x18, 0xf5, 0x72, 0x9f, 0x8b, 0x94, 0xc7, 0x0b, 0x93, 0xdb, 0x66, 0xfc,
	0x1c, 0xde, 0xce, 0x37, 0x78, 0xab, 0x69, 0x1f, 0x26, 0x84, 0x03, 0x78, 0x9d, 0x96, 0x93, 0x2b,
	0xaa, 0x49, 0x3b, 0x40, 0x64, 0x15, 0xae, 0x66, 0xdb, 0xe0, 0x09, 0xff, 0x76, 0xe1, 0xad, 0x67,
	0xe6, 0xf2, 0x17, 0x28, 0x6f, 0x78, 0x8c, 0xa7, 0xd9, 0x2b, 0x61, 0x73, 0x7d, 0x09, 0x1e, 0x66,
	0x49, 0x2e, 0x78, 0xa6, 0x0a, 0xfb, 0xae, 0xbd, 0xd7, 0x79, 0x80, 0xdc, 0x19, 0x58, 0x26, 0x5d,
	0xc7, 0x90, 0x13, 0x80, 0x5c, 0x8a, 0x1c, 0xa5, 0xe2, 0x58, 0xf8, 0x0d, 0x93, 0x21, 0x7a, 0x30,
	0xc3, 0xf9, 0x8a, 0x5a, 0x3e, 0x20, 0x95, 0xd8, 0xf6, 0xef, 0x0e, 0xec, 0x2c, 0xbf, 0x40, 0x9a,
	0xe0, 0xf2, 0xc4, 0xae, 0x9e, 0xcb, 0x13, 0x2d, 0x90, 0x5c, 0x48, 0x65, 0x95, 0x60, 0xce, 0x1a,
	0x9b, 0xe8, 0x05, 0x2d, 0x17, 0xcc, 0x9c, 0xcd, 0x53, 0xa9, 0x7f, 0x3f, 0xb1, 0x48, 0xfd, 0x2d,
	0x83, 0xaf, 0x6c, 0xcd, 0x67, 0x73, 0x35, 0xf1, 0xeb, 0x46, 0x14, 0xe6, 0xac, 0x57, 0x11, 0x7f,
	0x56, 0x98, 0x69, 0x5d, 0x95, 0x0d, 0xf0, 0x68, 0x05, 0x69, 0x7f, 0x01, 0x8f, 0xee, 0xd5, 0xfc,
	0x5f, 0x0f, 0x8c, 0x67, 0x1f, 0x98, 0xa7, 0xee, 0x13, 0xe7, 0xd9, 0x47, 0x7f, 0xdc, 0x1e, 0x39,
	0x7f, 0xde, 0x1e, 0x39, 0x7f, 0xdd, 0x1e, 0x39, 0x70, 0x28, 0xe4, 0xb8, 0xc3, 0x72, 0x16, 0x4f,
	0xb0, 0xa3, 0xb7, 0x71, 0x8a, 0x98, 0xa3, 0x2c, 0xff, 0x97, 0x27, 0xce, 0x3f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x13, 0xd9, 0x9f, 0x27, 0x45, 0x07, 0x00, 0x00,
}

func (m *LedgerMetadataFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerMetadataFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerMetadataFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CToken != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.CToken))
		i--
		dAtA[i] = 0x60
	}
	if len(m.CustomMetadata) > 0 {
		for iNdEx := len(m.CustomMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataFormats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Ctime != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.Ctime))
		i--
		dAtA[i] = 0x50
	}
	if m.AckQuorumSize != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.AckQuorumSize))
		i--
		dAtA[i] = 0x48
	}
	if m.Password != nil {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x42
	}
	if m.DigestType != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.DigestType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Segment) > 0 {
		for iNdEx := len(m.Segment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Segment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataFormats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.State == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.State))
		i--
		dAtA[i] = 0x28
	}
	if m.LastEntryId != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.LastEntryId))
		i--
		dAtA[i] = 0x20
	}
	if m.Length == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("length")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.Length))
		i--
		dAtA[i] = 0x18
	}
	if m.EnsembleSize == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ensembleSize")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.EnsembleSize))
		i--
		dAtA[i] = 0x10
	}
	if m.QuorumSize == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("quorumSize")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.QuorumSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LedgerMetadataFormat_Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerMetadataFormat_Segment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerMetadataFormat_Segment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FirstEntryId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("firstEntryId")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.FirstEntryId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EnsembleMember) > 0 {
		for iNdEx := len(m.EnsembleMember) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EnsembleMember[iNdEx])
			copy(dAtA[i:], m.EnsembleMember[iNdEx])
			i = encodeVarintDataFormats(dAtA, i, uint64(len(m.EnsembleMember[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LedgerMetadataFormatCMetadataMapEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerMetadataFormatCMetadataMapEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerMetadataFormatCMetadataMapEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LedgerRereplicationLayoutFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerRereplicationLayoutFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LedgerRereplicationLayoutFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("version")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Type == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	} else {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnderreplicatedLedgerFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnderreplicatedLedgerFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnderreplicatedLedgerFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ctime != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.Ctime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Replica) > 0 {
		for iNdEx := len(m.Replica) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Replica[iNdEx])
			copy(dAtA[i:], m.Replica[iNdEx])
			i = encodeVarintDataFormats(dAtA, i, uint64(len(m.Replica[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CookieFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InstanceId != nil {
		i -= len(*m.InstanceId)
		copy(dAtA[i:], *m.InstanceId)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.InstanceId)))
		i--
		dAtA[i] = 0x22
	}
	if m.LedgerDirs == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerDirs")
	} else {
		i -= len(*m.LedgerDirs)
		copy(dAtA[i:], *m.LedgerDirs)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.LedgerDirs)))
		i--
		dAtA[i] = 0x1a
	}
	if m.JournalDir == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("journalDir")
	} else {
		i -= len(*m.JournalDir)
		copy(dAtA[i:], *m.JournalDir)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.JournalDir)))
		i--
		dAtA[i] = 0x12
	}
	if m.BookieHost == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("bookieHost")
	} else {
		i -= len(*m.BookieHost)
		copy(dAtA[i:], *m.BookieHost)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.BookieHost)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LockDataFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockDataFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockDataFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BookieId != nil {
		i -= len(*m.BookieId)
		copy(dAtA[i:], *m.BookieId)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.BookieId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditorVoteFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditorVoteFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditorVoteFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BookieId != nil {
		i -= len(*m.BookieId)
		copy(dAtA[i:], *m.BookieId)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.BookieId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckAllLedgersFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAllLedgersFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckAllLedgersFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CheckAllLedgersCTime != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.CheckAllLedgersCTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlacementPolicyCheckFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementPolicyCheckFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementPolicyCheckFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlacementPolicyCheckCTime != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.PlacementPolicyCheckCTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicasCheckFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicasCheckFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicasCheckFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReplicasCheckCTime != nil {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.ReplicasCheckCTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BookieServiceInfoFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BookieServiceInfoFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BookieServiceInfoFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDataFormats(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDataFormats(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDataFormats(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataFormats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	return len(dAtA) - i, nil
}

func (m *BookieServiceInfoFormat_Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BookieServiceInfoFormat_Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BookieServiceInfoFormat_Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Extensions) > 0 {
		for iNdEx := len(m.Extensions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Extensions[iNdEx])
			copy(dAtA[i:], m.Extensions[iNdEx])
			i = encodeVarintDataFormats(dAtA, i, uint64(len(m.Extensions[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Auth) > 0 {
		for iNdEx := len(m.Auth) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Auth[iNdEx])
			copy(dAtA[i:], m.Auth[iNdEx])
			i = encodeVarintDataFormats(dAtA, i, uint64(len(m.Auth[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Protocol == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("protocol")
	} else {
		i -= len(*m.Protocol)
		copy(dAtA[i:], *m.Protocol)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.Protocol)))
		i--
		dAtA[i] = 0x22
	}
	if m.Host == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("host")
	} else {
		i -= len(*m.Host)
		copy(dAtA[i:], *m.Host)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.Host)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Port == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	} else {
		i = encodeVarintDataFormats(dAtA, i, uint64(*m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Id == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	} else {
		i -= len(*m.Id)
		copy(dAtA[i:], *m.Id)
		i = encodeVarintDataFormats(dAtA, i, uint64(len(*m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDataFormats(dAtA []byte, offset int, v uint64) int {
	offset -= sovDataFormats(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LedgerMetadataFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QuorumSize != nil {
		n += 1 + sovDataFormats(uint64(*m.QuorumSize))
	}
	if m.EnsembleSize != nil {
		n += 1 + sovDataFormats(uint64(*m.EnsembleSize))
	}
	if m.Length != nil {
		n += 1 + sovDataFormats(uint64(*m.Length))
	}
	if m.LastEntryId != nil {
		n += 1 + sovDataFormats(uint64(*m.LastEntryId))
	}
	if m.State != nil {
		n += 1 + sovDataFormats(uint64(*m.State))
	}
	if len(m.Segment) > 0 {
		for _, e := range m.Segment {
			l = e.Size()
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if m.DigestType != nil {
		n += 1 + sovDataFormats(uint64(*m.DigestType))
	}
	if m.Password != nil {
		l = len(m.Password)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.AckQuorumSize != nil {
		n += 1 + sovDataFormats(uint64(*m.AckQuorumSize))
	}
	if m.Ctime != nil {
		n += 1 + sovDataFormats(uint64(*m.Ctime))
	}
	if len(m.CustomMetadata) > 0 {
		for _, e := range m.CustomMetadata {
			l = e.Size()
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if m.CToken != nil {
		n += 1 + sovDataFormats(uint64(*m.CToken))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LedgerMetadataFormat_Segment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EnsembleMember) > 0 {
		for _, s := range m.EnsembleMember {
			l = len(s)
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if m.FirstEntryId != nil {
		n += 1 + sovDataFormats(uint64(*m.FirstEntryId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LedgerMetadataFormatCMetadataMapEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LedgerRereplicationLayoutFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovDataFormats(uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnderreplicatedLedgerFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Replica) > 0 {
		for _, s := range m.Replica {
			l = len(s)
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if m.Ctime != nil {
		n += 1 + sovDataFormats(uint64(*m.Ctime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CookieFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BookieHost != nil {
		l = len(*m.BookieHost)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.JournalDir != nil {
		l = len(*m.JournalDir)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.LedgerDirs != nil {
		l = len(*m.LedgerDirs)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.InstanceId != nil {
		l = len(*m.InstanceId)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockDataFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BookieId != nil {
		l = len(*m.BookieId)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuditorVoteFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BookieId != nil {
		l = len(*m.BookieId)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckAllLedgersFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckAllLedgersCTime != nil {
		n += 1 + sovDataFormats(uint64(*m.CheckAllLedgersCTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementPolicyCheckFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlacementPolicyCheckCTime != nil {
		n += 1 + sovDataFormats(uint64(*m.PlacementPolicyCheckCTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicasCheckFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicasCheckCTime != nil {
		n += 1 + sovDataFormats(uint64(*m.ReplicasCheckCTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BookieServiceInfoFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDataFormats(uint64(len(k))) + 1 + len(v) + sovDataFormats(uint64(len(v)))
			n += mapEntrySize + 1 + sovDataFormats(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BookieServiceInfoFormat_Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.Port != nil {
		n += 1 + sovDataFormats(uint64(*m.Port))
	}
	if m.Host != nil {
		l = len(*m.Host)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovDataFormats(uint64(l))
	}
	if len(m.Auth) > 0 {
		for _, s := range m.Auth {
			l = len(s)
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if len(m.Extensions) > 0 {
		for _, s := range m.Extensions {
			l = len(s)
			n += 1 + l + sovDataFormats(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDataFormats(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDataFormats(x uint64) (n int) {
	return sovDataFormats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LedgerMetadataFormat) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerMetadataFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerMetadataFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QuorumSize = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnsembleSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnsembleSize = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEntryId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastEntryId = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v LedgerMetadataFormat_State
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= LedgerMetadataFormat_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segment = append(m.Segment, &LedgerMetadataFormat_Segment{})
			if err := m.Segment[len(m.Segment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigestType", wireType)
			}
			var v LedgerMetadataFormat_DigestType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= LedgerMetadataFormat_DigestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DigestType = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckQuorumSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AckQuorumSize = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ctime = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomMetadata = append(m.CustomMetadata, &LedgerMetadataFormatCMetadataMapEntry{})
			if err := m.CustomMetadata[len(m.CustomMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CToken", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CToken = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("quorumSize")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ensembleSize")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("length")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerMetadataFormat_Segment) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnsembleMember", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnsembleMember = append(m.EnsembleMember, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstEntryId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FirstEntryId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("firstEntryId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerMetadataFormatCMetadataMapEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cMetadataMapEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cMetadataMapEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerRereplicationLayoutFormat) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerRereplicationLayoutFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerRereplicationLayoutFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("version")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnderreplicatedLedgerFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnderreplicatedLedgerFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnderreplicatedLedgerFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replica = append(m.Replica, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ctime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieFormat) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BookieHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BookieHost = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JournalDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JournalDir = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerDirs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LedgerDirs = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InstanceId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("bookieHost")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("journalDir")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ledgerDirs")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockDataFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockDataFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockDataFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BookieId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BookieId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditorVoteFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditorVoteFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditorVoteFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BookieId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BookieId = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAllLedgersFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAllLedgersFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAllLedgersFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckAllLedgersCTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckAllLedgersCTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementPolicyCheckFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementPolicyCheckFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementPolicyCheckFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementPolicyCheckCTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacementPolicyCheckCTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicasCheckFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicasCheckFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicasCheckFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasCheckCTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicasCheckCTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BookieServiceInfoFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BookieServiceInfoFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BookieServiceInfoFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &BookieServiceInfoFormat_Endpoint{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataFormats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataFormats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDataFormats
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDataFormats
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataFormats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDataFormats
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDataFormats
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDataFormats(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDataFormats
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BookieServiceInfoFormat_Endpoint) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Host = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = append(m.Auth, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataFormats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataFormats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extensions = append(m.Extensions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataFormats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataFormats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("host")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("protocol")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDataFormats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDataFormats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataFormats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDataFormats
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDataFormats
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDataFormats
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDataFormats        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDataFormats          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDataFormats = fmt.Errorf("proto: unexpected end of group")
)
