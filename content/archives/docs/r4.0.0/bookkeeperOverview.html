<!DOCTYPE html>
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE- 2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>
    <title>Apache BookKeeper - BookKeeper overview</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bootstrap -->
    <link href="/archives/css/bootstrap.min.css" rel="stylesheet">
    <link href="/archives/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/archives/css/styles.css" rel="stylesheet">
  </head>
  <body>
    <header class="navbar navbar-inverse navbar-static-top" role="banner">
      <div class="container">
    	<div class="navbar-header hidden-xs hidden-sm">
    	  <a class="navbar-brand navbar-logo" href="/archives/"><img class="img-responsive" src="/archives/img/bookkeeper_blk40.png" alt="Bookkeeper Logo" /></a>
    	</div>
    	<div class="navbar-header">
    	  <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
    	  </button>
    	  <a class="navbar-brand" href="/archives/">Apache BookKeeper</a>
    	</div>
    	<nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
    	  <ul class="nav navbar-nav">
    	    <li><a href="/archives/releases.html">Download</a></li>

    	    <li class="dropdown">
    	      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Documentation<span class="caret"></span></a>
    	      <ul class="dropdown-menu" role="menu">
		<li><a href="/archives/docs/master">Latest (master)</a></li>
		<li><ul>
		    <li><a href="/archives/docs/master/apidocs">Java API docs</a></li>
		    <li><a href="/archives/docs/master/bookkeeperTutorial.html">Tutorial</a></li>
		    <li><a href="/archives/docs/master/bookkeeperConfig.html">Admin guide</a></li>
		</ul><li>
                <li><a href="/archives/docs/r4.4.0">Release 4.4.0</a></li>
                <li class="divider"></li>
                <li>Older releases</li>
                <li><a href="/archives/docs/r4.3.2">Release 4.3.2</a></li>
                <li><a href="/archives/docs/r4.3.1">Release 4.3.1</a></li>
                <li><a href="/archives/docs/r4.3.0">Release 4.3.0</a></li>
                <li><a href="/archives/docs/r4.2.4">Release 4.2.4</a></li>
                <li><a href="/archives/docs/r4.2.3">Release 4.2.3</a></li>
                <li><a href="/archives/docs/r4.2.2">Release 4.2.2</a></li>
                <li><a href="/archives/docs/r4.2.1">Release 4.2.1</a></li>
                <li><a href="/archives/docs/r4.2.0">Release 4.2.0</a></li>
                <li><a href="/archives/docs/r4.1.0">Release 4.1.0</a></li>
                <li><a href="/archives/docs/r4.0.0">Release 4.0.0</a></li>
              </ul>
            </li>
            
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Get Involved<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                <li><a href="/archives/lists.html">Mailing Lists</a></li>
                <li><a href="/archives/irc.html">IRC</a></li>
                <li><a href="/archives/svn.html">Version Control</a></li>
                <li><a href="https://issues.apache.org/jira/browse/BOOKKEEPER">Issue Tracker</a></li>
              </ul>
            </li>

            <li><a href="https://cwiki.apache.org/confluence/display/BOOKKEEPER/Index">Wiki</a></li>
            <!--<li><a href="#">Hedwig</a></li>//-->
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Project Info<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                <li><a href="/archives/credits.html">Who are we?</a></li>
                <li><a href="/archives/bylaws.html">Bylaws</a></li>
                <li><a href="http://www.apache.org/licenses/">License</a></li>
                <li class="divider"></li>
                <li><a href="/archives/privacy.html">Privacy Policy</a></li>
                <li><a href="http://www.apache.org/foundation/sponsorship.html">Sponsership</a></li>
                <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
              </ul>
            </li>
          </ul>
          <script>
            (function() {
            var cx = '017580107654524087317:iqnsyimpydg';
            var gcse = document.createElement('script');
            gcse.type = 'text/javascript';
            gcse.async = true;
            gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//www.google.com/cse/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(gcse, s);
            })();
          </script>
          
          <div class="navbar-form navbar-right visible-lg" id="googlebox">
            <gcse:searchbox-only></gcse:searchbox-only>
          </div>
        </nav>
      </div>
    </header>
    <div class="container">

 <h1>Abstract</h1>

<p>This guide contains detailed information about using BookKeeper for logging. It discusses the basic operations BookKeeper supports, and how to create logs and perform basic read and write operations on these logs.</p>

<h1>BookKeeper introduction</h1>

<p>BookKeeper is a replicated service to reliably log streams of records. In BookKeeper, servers are "bookies", log streams are "ledgers", and each unit of a log (aka record) is a "ledger entry". BookKeeper is designed to be reliable; bookies, the servers that store ledgers, can crash, corrupt data, discard data, but as long as there are enough bookies behaving correctly the service as a whole behaves correctly. </p>

<p>The initial motivation for BookKeeper comes from the namenode of <span class="caps">HDFS.</span> Namenodes have to log operations in a reliable fashion so that recovery is possible in the case of crashes. We have found the applications for BookKeeper extend far beyond <span class="caps">HDFS, </span>however. Essentially, any application that requires an append storage can replace their implementations with BookKeeper. BookKeeper has the advantage of writing efficiently, replicating for fault tolerance, and scaling throughput with the number of servers through striping. </p>

<p>At a high level, a bookkeeper client receives entries from a client application and stores it to sets of bookies, and there are a few advantages in having such a service: </p>

<ul>
<li>We can use hardware that is optimized for such a service. We currently believe that such a system has to be optimized only for disk I/O; </li>
<li>We can have a pool of servers implementing such a log system, and shared among a number of servers; </li>
<li>We can have a higher degree of replication with such a pool, which makes sense if the hardware necessary for it is cheaper compared to the one the application uses. </li>
</ul>


<h1>In slightly more detail...</h1>

<p>BookKeeper implements highly available logs, and it has been designed with write-ahead logging in mind. Besides high availability due to the replicated nature of the service, it provides high throughput due to striping. As we write entries in a subset of bookies of an ensemble and rotate writes across available quorums, we are able to increase throughput with the number of servers for both reads and writes. Scalability is a property that is possible to achieve in this case due to the use of quorums. Other replication techniques, such as state-machine replication, do not enable such a property. </p>

<p>An application first creates a ledger before writing to bookies through a local BookKeeper client instance. Upon creating a ledger, a BookKeeper client writes metadata about the ledger to ZooKeeper. Each ledger currently has a single writer. This writer has to execute a close ledger operation before any other client can read from it. If the writer of a ledger does not close a ledger properly because, for example, it has crashed before having the opportunity of closing the ledger, then the next client that tries to open a ledger executes a procedure to recover it. As closing a ledger consists essentially of writing the last entry written to a ledger to ZooKeeper, the recovery procedure simply finds the last entry written correctly and writes it to ZooKeeper. </p>

<p>Note that currently this recovery procedure is executed automatically upon trying to open a ledger and no explicit action is necessary. Although two clients may try to recover a ledger concurrently, only one will succeed, the first one that is able to create the close znode for the ledger. </p>

<h1>Bookkeeper elements and concepts</h1>

<p>BookKeeper uses four basic elements: </p>

<ul>
<li> <em>Ledger</em> : A ledger is a sequence of entries, and each entry is a sequence of bytes. Entries are written sequentially to a ledger and at most once. Consequently, ledgers have an append-only semantics; </li>
<li> <em>BookKeeper client</em> : A client runs along with a BookKeeper application, and it enables applications to execute operations on ledgers, such as creating a ledger and writing to it; </li>
<li> <em>Bookie</em> : A bookie is a BookKeeper storage server. Bookies store the content of ledgers. For any given ledger L, we call an <em>ensemble</em> the group of bookies storing the content of L. For performance, we store on each bookie of an ensemble only a fragment of a ledger. That is, we stripe when writing entries to a ledger such that each entry is written to sub-group of bookies of the ensemble. </li>
<li> <em>Metadata storage service</em> : BookKeeper requires a metadata storage service to store information related to ledgers and available bookies. We currently use ZooKeeper for such a task. </li>
</ul>


<h1>Bookkeeper initial design</h1>

<p>A set of bookies implements BookKeeper, and we use a quorum-based protocol to replicate data across the bookies. There are basically two operations to an existing ledger: read and append. Here is the complete <span class="caps">API </span>list (mode detail <a href="http://bookkeeperProgrammer.html">here</a>): </p>

<ul>
<li>Create ledger: creates a new empty ledger; </li>
<li>Open ledger: opens an existing ledger for reading; </li>
<li>Add entry: adds a record to a ledger either synchronously or asynchronously; </li>
<li>Read entries: reads a sequence of entries from a ledger either synchronously or asynchronously </li>
</ul>


<p>There is only a single client that can write to a ledger. Once that ledger is closed or the client fails, no more entries can be added. (We take advantage of this behavior to provide our strong guarantees.) There will not be gaps in the ledger. Fingers get broken, people get roughed up or end up in prison when books are manipulated, so there is no deleting or changing of entries. </p>

<p><img src="images/bk-overview.jpg" alt="" />
p. A simple use of BooKeeper is to implement a write-ahead transaction log. A server maintains an in-memory data structure (with periodic snapshots for example) and logs changes to that structure before it applies the change. The application server creates a ledger at startup and store the ledger id and password in a well known place (ZooKeeper maybe). When it needs to make a change, the server adds an entry with the change information to a ledger and apply the change when BookKeeper adds the entry successfully. The server can even use asyncAddEntry to queue up many changes for high change throughput. BooKeeper meticulously logs the changes in order and call the completion functions in order. </p>

<p>When the application server dies, a backup server will come online, get the last snapshot and then it will open the ledger of the old server and read all the entries from the time the snapshot was taken. (Since it doesn't know the last entry number it will use <span class="caps">MAX</span>_INTEGER). Once all the entries have been processed, it will close the ledger and start a new one for its use. </p>

<p>A client library takes care of communicating with bookies and managing entry numbers. An entry has the following fields: </p>

<table><tr><td>Field</td><td>Type</td><td>Description</td></tr><tr><td>Ledger number</td><td>long</td><td>The id of the ledger of this entry</td></tr><tr><td>Entry number</td><td>long</td><td>The id of this entry</td></tr><tr><td>last confirmed ( <em>LC</em> )</td><td>long</td><td>id of the last recorded entry</td></tr><tr><td>data</td><td>byte[]</td><td>the entry data (supplied by application)</td></tr><tr><td>authentication code</td><td>byte[]</td><td>Message authentication code that includes all other fields of the entry</td></tr></table>


<p>The client library generates a ledger entry. None of the fields are modified by the bookies and only the first three fields are interpreted by the bookies. </p>

<p>To add to a ledger, the client generates the entry above using the ledger number. The entry number will be one more than the last entry generated. The <em>LC</em> field contains the last entry that has been successfully recorded by BookKeeper. If the client writes entries one at a time, <em>LC</em> is the last entry id. But, if the client is using asyncAddEntry, there may be many entries in flight. An entry is considered recorded when both of the following conditions are met: </p>

<ul>
<li>the entry has been accepted by a quorum of bookies </li>
<li>all entries with a lower entry id have been accepted by a quorum of bookies </li>
</ul>


<p> <em>LC</em> seems mysterious right now, but it is too early to explain how we use it; just smile and move on. </p>

<p>Once all the other fields have been field in, the client generates an authentication code with all of the previous fields. The entry is then sent to a quorum of bookies to be recorded. Any failures will result in the entry being sent to a new quorum of bookies. </p>

<p>To read, the client library initially contacts a bookie and starts requesting entries. If an entry is missing or invalid (a bad <span class="caps">MAC </span>for example), the client will make a request to a different bookie. By using quorum writes, as long as enough bookies are up we are guaranteed to eventually be able to read an entry. </p>

<h1>Bookkeeper metadata management</h1>

<p>There are some meta data that needs to be made available to BookKeeper clients: </p>

<ul>
<li>The available bookies; </li>
<li>The list of ledgers; </li>
<li>The list of bookies that have been used for a given ledger; </li>
<li>The last entry of a ledger; </li>
</ul>


<p>We maintain this information in ZooKeeper. Bookies use ephemeral nodes to indicate their availability. Clients use znodes to track ledger creation and deletion and also to know the end of the ledger and the bookies that were used to store the ledger. Bookies also watch the ledger list so that they can cleanup ledgers that get deleted. </p>

<h1>Closing out ledgers</h1>

<p>The process of closing out the ledger and finding the last entry is difficult due to the durability guarantees of BookKeeper: </p>

<ul>
<li>If an entry has been successfully recorded, it must be readable. </li>
<li>If an entry is read once, it must always be available to be read. </li>
</ul>


<p>If the ledger was closed gracefully, ZooKeeper will have the last entry and everything will work well. But, if the BookKeeper client that was writing the ledger dies, there is some recovery that needs to take place. </p>

<p>The problematic entries are the ones at the end of the ledger. There can be entries in flight when a BookKeeper client dies. If the entry only gets to one bookie, the entry should not be readable since the entry will disappear if that bookie fails. If the entry is only on one bookie, that doesn't mean that the entry has not been recorded successfully; the other bookies that recorded the entry might have failed. </p>

<p>The trick to making everything work is to have a correct idea of a last entry. We do it in roughly three steps: </p>

<ol>
<li>Find the entry with the highest last recorded entry, <em>LC</em> ; </li>
<li>Find the highest consecutively recorded entry, <em>LR</em> ; </li>
<li>Make sure that all entries between <em>LC</em> and <em>LR</em> are on a quorum of bookies; </li>
</ol>

<h1>Data Management in Bookies</h1>

<p>This section gives an overview of how a bookie manages its ledger fragments. </p>

<h2>Basic</h2>

<p>Bookies manage data in a log-structured way, which is implemented using three kind of files:</p>

<ul>
<li><em>Journal</em> : A journal file contains the BookKeeper transaction logs. Before any update takes place, a bookie ensures that a transaction describing the update is written to non-volatile storage. A new journal file is created once the bookie starts or the older journal file reaches the journal file size threshold.</li>
<li><em>Entry Log</em> : An entry log file manages the written entries received from BookKeeper clients. Entries from different ledgers are aggregated and written sequentially, while their offsets are kept as pointers in <em>LedgerCache</em> for fast lookup. A new entry log file is created once the bookie starts or the older entry log file reaches the entry log size threshold. Old entry log files are removed by the <em>Garbage Collector Thread</em> once they are not associated with any active ledger.</li>
<li><em>Index File</em> : An index file is created for each ledger, which comprises a header and several fixed-length index pages, recording the offsets of data stored in entry log files. </li>
</ul>

<p>Since updating index files would introduce random disk I/O, for performance consideration, index files are updated lazily by a <em>Sync Thread</em> running in the background. Before index pages are persisted to disk, they are gathered in <em>LedgerCache</em> for lookup.</p>

<ul>
<li><em>LedgerCache</em> : A memory pool caches ledger index pages, which more efficiently manage disk head scheduling.</li>
</ul>

<h2>Add Entry</h2>

<p>When a bookie receives entries from clients to be written, these entries will go through the following steps to be persisted to disk:</p>

<ol>
<li>Append the entry in <em>Entry Log</em>, return its position { logId , offset } ;</li>
<li>Update the index of this entry in <em>Ledger Cache</em> ;</li>
<li>Append a transaction corresponding to this entry update in <em>Journal</em> ;</li>
<li>Respond to BookKeeper client ;</li>
</ol>

<ul>
<li>For performance reasons, <em>Entry Log</em> buffers entries in memory and commit them in batches, while <em>Ledger Cache</em> holds index pages in memory and flushes them lazily. We will discuss data flush and how to ensure data integrity in the following section 'Data Flush'.</li>
</ul>

<h2>Data Flush</h2>

<p>Ledger index pages are flushed to index files in the following two cases:</p>

<ol>
<li><em>LedgerCache</em> memory reaches its limit. There is no more space available to hold newer index pages. Dirty index pages will be evicted from <em>LedgerCache</em> and persisted to index files.</li>
<li>A background thread <em>Sync Thread</em> is responsible for flushing index pages from <em>LedgerCache</em> to index files periodically.</li>
</ol>

<p>Besides flushing index pages, <em>Sync Thread</em> is responsible for rolling journal files in case that journal files use too much disk space. </p>

<p>The data flush flow in <em>Sync Thread</em> is as follows:</p>

<ol>
<li>Records a <em>LastLogMark</em> in memory. The <em>LastLogMark</em> contains two parts: first one is <em>txnLogId</em> (file id of a journal) and the second one is <em>txnLogPos</em> (offset in a journal). The <em>LastLogMark</em> indicates that those entries before it have been persisted to both index and entry log files.</li>
<li>Flushes dirty index pages from <em>LedgerCache</em> to index file, and flushes entry log files to ensure all buffered entries in entry log files are persisted to disk.<ol>
<li>Ideally, a bookie just needs to flush index pages and entry log files that contains entries before <em>LastLogMark</em>. There is no such information in <em>LedgerCache</em> and <em>Entry Log</em> mapping to journal files, though. Consequently, the thread flushes <em>LedgerCache</em> and <em>Entry Log</em> entirely here, and may flush entries after the <em>LastLogMark</em>. Flushing more is not a problem, though, just redundant.</li>
</ol>
</li>
<li>Persists <em>LastLogMark</em> to disk, which means entries added before <em>LastLogMark</em> whose entry data and index page were also persisted to disk. It is the time to safely remove journal files created earlier than <em>txnLogId</em>.<ol>
<li>If the bookie has crashed before persisting <em>LastLogMark</em> to disk, it still has journal files containing entries for which index pages may not have been persisted. Consequently, when this bookie restarts, it inspects journal files to restore those entries; data isn't lost.</li>
</ol></li>
</ol>

<p>Using the above data flush mechanism, it is safe for the <em>Sync Thread</em> to skip data flushing when the bookie shuts down. However, in <em>Entry Logger</em>, it uses <em>BufferedChannel</em> to write entries in batches and there might be data buffered in <em>BufferedChannel</em> upon a shut down. The bookie needs to ensure <em>Entry Logger</em> flushes its buffered data during shutting down. Otherwise, <em>Entry Log</em> files become corrupted with partial entries.</p>

<p>As described above, <em>EntryLogger#flush</em> is invoked in the following two cases:<br />
* in <em>Sync Thread</em> : used to ensure entries added before <em>LastLogMark</em> are persisted to disk.<br />
* in <em>ShutDown</em> : used to ensure its buffered data persisted to disk to avoid data corruption with partial entries.</p>

    </div>
    <footer class="footer">
      <div class="container">
        <p class="text-muted">Copyright &copy; 2014 The Apache Software Foundation, Licensed under the Apache License, Version 2.0.<br/>
	Apache BookKeeper, BookKeeper, Apache, Apache ZooKeeper, ZooKeeper, the Apache feather logo, and the Apache BookKeeper project logo are trademarks of The Apache Software Foundation.</p>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery.js"></script>
    <script src="/archives/js/bootstrap.min.js"></script>
  </body>
</html>
