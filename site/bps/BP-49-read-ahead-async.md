---
title: "BP-49: Support reading ahead in async mode"
issue: https://github.com/apache/bookkeeper/issues/3085
state: "Under Discussion"
release: "n/a"
---

### Motivation

#### Current Design of Read-ahead

Under the current design of read-ahead, every `read-entry` request that the entry data is required to be read from main storage eventually, will force a read-ahead operation through the method `org.apache.bookkeeper.bookie.storage.ldb.SingleDirectoryDbLedgerStorage.fillReadAheadCache`. This method will read several entries after the current position and load them into the read-cache, among which the amount of entries is controlled by the `dbStorage_readAheadCacheBatchSize`.

In this mode, once a miss of read-cache occurs, the elapsed time of reading an entry is equivalent to the sum of the time of reading that entry plus reading several entries after the entry, because the process of read-ahead is synchronous.

Synchronous read-ahead is a simple and effective solution in scenarios where read latency is less of a concern. However, we found that when the cluster has a large number of catch-up reads, and the p99 latency cannot be ignored, synchronous read-ahead may introduce a lot of latency glitches. Therefore, we decided to introduce an asynchronous read-ahead mode to reduce the latency for the catch-up reads.

#### Proposed Approach

Instead of modifying the original synchronous read-ahead logic, we introduced an independent asynchronous read-ahead module named `ReadAheadManager`. The user can select a specific read-ahead mode through configuration parameters. The async read-ahead module will provide an interface for reading entry for upper-layer logic.

#### Evaluation Results

> See the master issue

Before diving into the details, let's take a look at the performance optimizations brought by asynchronous read-ahead.

##### Hit / Miss Count of Read Cache

##### AVG Time of Read-Entry Op

### Public Interfaces

#### Public Class and Method

```java
public class ReadAheadManager {
	
    // the entrance of reading an entry in async ra mode
	public ByteBuf readEntryOrWait(long ledgerId, long entryId) throws IOException {
		// read entry from cache directly
		// or waiting the completion of an async read-ahead task
	}
}
```

#### Monitoring

##### Summary Metrics
- total time of read-ahead
- queuing time of read-ahead async
- execution time of read-ahead async
- blocking time of reading an entry in async mode

##### Counter Metrics
- hitting count of `read-cache`
- missing count of `read-cache`
- read-ahead entries count
- read-ahead bytes count

### Proposed Changes

#### Design

##### Core Components

- `ReadAheadManager`: management class, which is responsible for submitting/executing read-ahead task, and cleaning up the expired tasks.
- `ReadAheadTaskStatus`: the class to record the status of a read-ahead task, including initial read position, window size of read-ahead and the task execution progress.

- `pending_ra_pos_map`: stores the actual locations that may need to be read ahead.
- `ra_task_state_map`: stores the states of those read-ahead tasks submitted asynchronously.

##### Principles

- When should the read-ahead be triggered?

	- Sequential read behavior should trigger read-ahead;

	- Only read a single entry from disk should not trigger read-ahead;

- When should read-ahead locations be recorded?

	- When all levels of cache fail to hit the target entry, a disk read must be triggered. Before returning the entry, put the `entry+1` position into the `pending_ra_map`.

	- When the asynchronous read-ahead task is completed, the `pre_ra_pos position` (the default value is the position of the entry in the 75th percentile of the read-ahead entry list) is put into the `pending_ra_map`;

- When should the read-ahead task actually be submitted?

	- When the target entry exists in `pending_ra_map`, the read-ahead task will be submitted asynchronously in the background.

- How does the read-ahead window change?

	- Currently it is a fixed size, and the relative parameters are configurable.

- How to read an entry that its corresponding read-ahead task has not yet completed?

	- If the target entry is belong to an un-completed read-ahead task, it will block and wait until the read-ahead task is completed, and then return the entry data.

	- Sub-question: Granularity of blocking?

		- At present, the blocking granularity is the window size of a read-ahead task, not the granularity of each entry, so as to avoid creating too many locks.

- Where is the read-ahead data stored?

	- The data generated by the read-ahead task is stored in `org.apache.bookkeeper.bookie.storage.ldb.ReadCache`. The current cache structure is reused, and the data exists in the off-heap space.

### Compatibility, Deprecation, and Migration Plan

The asynchronous read-ahead module is completely independent. Only when the user modifies the read-ahead mode, the asynchronous read-ahead will start to work. In addition, different read-ahead modes will not affect the existing entry reading process, but only affect how many entries are cached at what time.

### Test Plan

These changes have been extensively tested and applied on our production clusters to ensure that rate limiting features and monitoring metrics are accurate and useful.

### Rejected Alternatives

None